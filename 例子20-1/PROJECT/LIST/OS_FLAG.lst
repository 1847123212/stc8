C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE OS_FLAG
OBJECT MODULE PLACED IN .\OUTPUT\OS_FLAG.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\uCOSII\OS_FLAG.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PR
                    -INT(.\LIST\OS_FLAG.lst) TABS(2) OBJECT(.\OUTPUT\OS_FLAG.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                         EVENT FLAG  MANAGEMENT
   6          *
   7          *                          (c) Copyright 2001-2002, Jean J. Labrosse, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File : OS_FLAG.C
  11          * By   : Jean J. Labrosse
  12          *********************************************************************************************************
  13          */
  14          
  15          #ifndef  OS_MASTER_FILE
  16          #include "..\APP\includes.h"
  17          #endif
  18          
  19          #if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
              /*
              *********************************************************************************************************
              *                                            LOCAL PROTOTYPES
                                                                  æ÷≤ø∂®“Â
              *********************************************************************************************************
              */
              
              static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT
             -16U timeout);
              static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
              *
              * Description: This function is called to check the status of a combination of bits to be set or cleared
              *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
              *              bits to be set/cleared.
              *
              *              This call does not block if the desired flags are not present.
              *
              * Arguments  : pgrp          is a pointer to the desired event flag group.
              *
              *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
              *                            The bits you want are specified by setting the corresponding bits in
              *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
              *                            'flags' would contain 0x03.
              *
              *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
              *                            to be set/cleared.
              *                            You can specify the following argument:
              *
              *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
              *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 2   

              *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
              *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
              *
              *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
              *                                  the call.  Example, to wait for any flag in a group AND then clear
              *                                  the flags that are present, set 'wait_type' to:
              *
              *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
              *
              *              err           is a pointer to an error code and can be:
              *                            OS_NO_ERR              No error
              *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
              *                            OS_FLAG_ERR_WAIT_TYPE  You didn't specify a proper 'wait_type' argument.
              *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer instead of the event flag
              *                                                   group handle.
              *                            OS_FLAG_ERR_NOT_RDY    The desired flags you are waiting for are not
              *                                                   available.
              *
              * Returns    : The state of the flags in the event flag group.
              *
              * Called from: Task or ISR
                                                  Œﬁµ»¥˝µÿªÒµ√ ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æ
              √Ë ˆ£∫»•ºÏ≤È ¬º˛±Í÷æ◊È÷–Ω·∫œŒªµƒ◊¥Ã¨ «÷√Œªªπ «±ª«Â≥˝£¨ƒ„ƒ‹
                              ºÏ≤È»Œ∫ŒΩ´±ª÷√ŒªªÚ’ﬂ«Â≥˝µƒŒªªÚ’ﬂ»´≤øŒª
                              »Áπ˚µ»¥˝ ¬º˛≤ª∑¢…˙£¨µ˜”√ ¬º˛≤¢≤ªπ“∆°£”ÎOSFlagPend()Œ®“ª≤ªÕ¨µ„
              ≤Œ ˝£∫pgrp£∫÷∏œÚƒø±Í ¬º˛±Í÷æ◊Èµƒ÷∏’Î
                              flags£∫ «“ª∏ˆŒªµƒƒ£ Ωœ‘ æ“™ºÏ≤ÈµƒŒª£¨±»»Á£∫ƒ„“™ºÏ≤‚0Œª∫Õ1Œª£¨ƒ«√¥ƒ„Ω´À¸
                                         …Ë÷√Œ™0x03
                              wait_type £∫±Íº«ƒ„œÎ»´≤øºÏ≤‚ªπ «÷ªœÎºÏ≤‚∆‰ µ“ª≤ø∑÷°£ƒ„ƒ‹±Íº«»Áœ¬≤Œ ˝£∫
              *                            OS_FLAG_WAIT_CLR_ALL   ƒ„Ω´ºÏ≤‚flags÷–»´≤øµƒ«Â¡„Œª
              *                            OS_FLAG_WAIT_CLR_ANY   ƒ„Ω´ºÏ≤‚flags÷–»Œ∫Œ«Â¡„Œª
              *                            OS_FLAG_WAIT_SET_ALL   ƒ„Ω´ºÏ≤‚flags÷–»´≤øµƒ÷√“ªŒª
              *                            OS_FLAG_WAIT_SET_ANY   ƒ„Ω´ºÏ≤‚flags÷–»Œ∫Œ÷√“ªŒª
                             »Áπ˚œÎ ¬º˛±Í÷æ±ªµ˜”√∫Ø ˝«Â≥˝µƒª∞£¨“™º”…œOS_FLAG_CONSUME£¨±»»Á£∫»Áπ˚
                             œÎ“™◊È”Î∫Û«Â≥˝£¨ƒ«√¥Ω´wait_type…Ë÷√≥…OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                             err ÷∏œÚ¥ÌŒÛ¥˙¬Îµƒ÷∏’Î£¨ø…“‘Œ™£∫
              *                            OS_NO_ERR             ŒﬁŒÛ
              *                            OS_ERR_EVENT_TYPE      √ª”–÷∏œÚ»ŒŒÒ ¬º˛±Í÷æ◊È
              *                            OS_FLAG_ERR_WAIT_TYPE  ƒ„√ª”–…Ë÷√’˝»∑µƒ 'wait_type' ≤Œ ˝
              *                            OS_FLAG_INVALID_PGRP   ƒ„¥´ÀÕ¡À¡„÷∏’Î∂¯≤ª « ¬º˛±Í÷æ◊È≤Ÿ◊˜
              *                            OS_FLAG_ERR_NOT_RDY    ƒ„µ»¥˝µƒƒø±Í±Í÷æ≤ª∫œ¿Ì
              ∑µªÿ£∫ ¬º˛±Í÷æ◊Èµƒ±Í÷æ◊¥Ã¨
              ¥”»ŒŒÒ∫ÕISR÷–µ˜”√
              *********************************************************************************************************
              */
              
              #if OS_FLAG_ACCEPT_EN > 0
              OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR     cpu_sr;
              #endif
                  OS_FLAGS      flags_cur;
                  OS_FLAGS      flags_rdy;
                  BOOLEAN       consume;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                      *err = OS_FLAG_INVALID_PGRP;
                      return ((OS_FLAGS)0);//∑«ø’µƒpgrp'
                  }
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 3   

                  if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
                      *err = OS_ERR_EVENT_TYPE;
                      return ((OS_FLAGS)0);//∫œ¿Ìµƒ ¬º˛øÿ÷∆øÈ¿‡–Õ
                  }
              #endif
                  if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
                      wait_type &= ~OS_FLAG_CONSUME;
                      consume    = TRUE;
                  } else {
                      consume    = FALSE;
                  }// «∑Ò–Ë“™«Â≥˝Œª
              /*$PAGE*/
                  *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
              //≥ı ºªØŒﬁ¥Ì
                  OS_ENTER_CRITICAL();
                  switch (wait_type) {
                      case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                           flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
                           if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                               //»Áπ˚∏’∫√ «Œ“√«“™µƒ
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
                               }// «∑Ò“™«Â≥˝
                           } else {
                               *err  = OS_FLAG_ERR_NOT_RDY;//√ª”–Œ“√«œÎ“™µƒ£¨∑µªÿ≤ª∫œ¿Ì
                           }
                           flags_cur = pgrp->OSFlagFlags;                /* Will return the state of the group       */
                     //∑µªÿ±Í÷æ
                           OS_EXIT_CRITICAL();
                           break;
              
                      case OS_FLAG_WAIT_SET_ANY:
                           flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
                           if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                      // «∑Ò”–±Í÷æ÷√Œª
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
                               }// «∑Ò–Ë“™«Â≥˝Œª
                           } else {//√ª”–±Í÷æ÷√Œª
                               *err  = OS_FLAG_ERR_NOT_RDY;
                           }
                           flags_cur = pgrp->OSFlagFlags;                /* Will return the state of the group       */
                     //∑µªÿ◊È◊¥Ã¨£¨
                           OS_EXIT_CRITICAL();
                           break;
              
              #if OS_FLAG_WAIT_CLR_EN > 0
                      case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                           flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
                     //…Ë÷√Œª
                           if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                      //±ÿ–ÎÀ˘”–µƒŒª∂º∆•≈‰
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
                               }// «∑Ò“™…Ë÷√Œª
                           } else {
                               *err  = OS_FLAG_ERR_NOT_RDY;//≤ª «À˘”–Œª∂º∆•≈‰
                           }
                           flags_cur = pgrp->OSFlagFlags;                /* Will return the state of the group       */
                     //∑µªÿ±Í÷æ◊È◊¥Ã¨
                           OS_EXIT_CRITICAL();
                           break;
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 4   

              
                      case OS_FLAG_WAIT_CLR_ANY:
                           flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
                           if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                               }
                           } else {
                               *err  = OS_FLAG_ERR_NOT_RDY;
                           }
                           flags_cur = pgrp->OSFlagFlags;                /* Will return the state of the group       */
                           OS_EXIT_CRITICAL();
                           break;
              #endif
              
                      default://∆‰À¸“Ï≥£«Èøˆ
                           OS_EXIT_CRITICAL();
                           flags_cur = (OS_FLAGS)0;
                           *err      = OS_FLAG_ERR_WAIT_TYPE;
                           break;
                  }
                  return (flags_cur);//∑µªÿ◊¥Ã¨
              }
              #endif
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                           CREATE AN EVENT FLAG
              *
              * Description: This function is called to create an event flag group.
              *
              * Arguments  : flags         Contains the initial value to store in the event flag group.
              *
              *              err           is a pointer to an error code which will be returned to your application:
              *                               OS_NO_ERR                if the call was successful.
              *                               OS_ERR_CREATE_ISR        if you attempted to create an Event Flag from an
              *                                                        ISR.
              *                               OS_FLAG_GRP_DEPLETED     if there are no more event flag groups
              *
              * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
              *
              * Called from: Task ONLY
                                                                   Ω®¡¢“ª∏ˆ ¬º˛±Í÷æ◊È
              √Ë ˆ£∫Ω®¡¢“ª∏ˆ ¬º˛±Í÷æ◊È
              ≤Œ ˝£∫flags£∫∞¸∫¨¥Ê¥¢‘⁄ ¬º˛±Í÷æ◊È÷–µƒ≥ı º÷µ
                              err£∫Ω´∑µªÿµΩƒ„”¶”√≥Ã–Úµƒ¥ÌŒÛ–≈œ¢
               *                               OS_NO_ERR                »Áπ˚≥…π¶
              *                               OS_ERR_CREATE_ISR       »Áπ˚ƒ„œÎ¥”ISR÷–Ω®¡¢
              *                               OS_FLAG_GRP_DEPLETED    »Áπ˚√ª”–∂‡”‡µƒ ¬º˛±Í÷æ◊È¡À               
              *********************************************************************************************************
              */
              
              OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
                  OS_CPU_SR    cpu_sr;
              #endif
                  OS_FLAG_GRP *pgrp;
              
              
                  if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 5   

                      *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
                      return ((OS_FLAG_GRP *)0);//≤ªƒ‹¥”ISR÷–Ω®¡¢
                  }
                  OS_ENTER_CRITICAL();
                  pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
                //÷∏œÚø’¡¥±Ìµƒø’µÿ÷∑ £¨»°µ√“ª∏ˆø’œ– ¬º˛±Í÷æ
                  if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                /* Adjust free list       *///»Áπ˚Œ™0£¨±Ì√˜√ª”–ø’œ–µƒ ¬º˛±Í÷æ◊È¡À
                      OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
                  //µ˜’˚œµÕ≥µƒø’œ– ¬º˛±Í÷æ◊È¡¥±Ì÷∏’Î£¨ π÷Æ÷∏œÚ–¬µƒ±ÌÕ∑
                      pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
                  //∑÷≈‰À¸ « ¬º˛±Í÷æ◊È£¨»∑±£ƒ‹œµÕ≥’˝≥£‘À––
                      pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
                  //Ω´≥ı ºªØ÷µ¥´»Î’‚∏ˆ ¬º˛±Í÷æ◊È
                      pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
                  //“ÚŒ™ «∏’∏’Ω®¡¢µƒ ¬º˛±Í÷æ◊È£¨√ª”–»Œ∫Œ»ŒŒÒµ»¥˝’‚∏ˆ ¬º˛±Í÷æ◊È£¨
                  //À˘“‘µ»¥˝»ŒŒÒ¡¥±Ì÷∏’Î≥ı ºªØŒ™0
                      OS_EXIT_CRITICAL();
                      *err                 = OS_NO_ERR;
                  } else {//»Áπ˚√ª”–ø’œ–µƒ ¬º˛±Í÷æ◊È¡À
                      OS_EXIT_CRITICAL();
                      *err                 = OS_FLAG_GRP_DEPLETED;
                  }
                  return (pgrp);                                  /* Return pointer to event flag group     */
                //∑µªÿ∏’∏’Ω®¡¢µƒ ¬º˛±Í÷æ◊È÷∏’Î£¨»Áπ˚√ª”–ø’œ–µƒ ¬º˛±Í÷æ◊È£¨
                //Ω´∑µªÿNULL÷∏’Î
              }
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                     DELETE AN EVENT FLAG GROUP
              *
              * Description: This function deletes an event flag group and readies all tasks pending on the event flag
              *              group.
              * Arguments  : pgrp          is a pointer to the desired event flag group.
              *
              *              opt           determines delete options as follows:
              *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
              *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
              *                                                    waiting.  In this case, all the tasks pending will be
              *                                                    readied.
              *
              *              err           is a pointer to an error code that can contain one of the following values:
              *                            OS_NO_ERR               The call was successful and the event flag group was
              *                                                    deleted
              *                            OS_ERR_DEL_ISR          If you attempted to delete the event flag group from
              *                                                    an ISR
              *                            OS_FLAG_INVALID_PGRP    If 'pgrp' is a NULL pointer.
              *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to an event flag group
              *                            OS_ERR_INVALID_OPT      An invalid option was specified
              *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the event flag
              *                                                    group.
              * Returns    : pevent        upon error
              *              (OS_EVENT *)0 if the semaphore was successfully deleted.
              *
              * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
              *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
              *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
              *                 time is directly proportional to the number of tasks waiting on the event flag group.
                                                                              …æ≥˝“ª∏ˆ ¬º˛±Í÷æ◊È
              √Ë ˆ£∫…æ≥˝“ª∏ˆ ¬º˛±Í÷æ◊È£¨Ω´ ¬º˛±Í÷æ◊È÷–À˘”–π“∆µƒ»ŒŒÒæÕ–˜°£
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 6   

              ≤Œ ˝£∫pgrp£∫÷∏œÚƒø±Í ¬º˛±Í÷æ◊Èµƒ÷∏’Î
                              opt£∫æˆ∂®“‘œ¬…æ≥˝—°œÓ£∫
              *                            opt == OS_DEL_NO_PEND   √ª”–»ŒŒÒπ“∆µƒ ±∫Ú≤≈…æ ¬º˛±Í÷æ◊È
              *                            opt == OS_DEL_ALWAYS    º¥ π”–»ŒŒÒµ»¥˝“≤…æ≥˝£¨’‚∏ˆ£¨À˘”–π“∆µƒ
                                                             »ŒŒÒΩ´æÕ–˜°£
               *              err           ∞¸∫¨“‘œ¬¥ÌŒÛ–≈œ¢÷Æ“ªµƒ÷∏’Î
              *                            OS_NO_ERR              µ˜”√≥…π¶£¨ ¬º˛±Í÷æ◊È≥…π¶…æ≥˝
              *                            OS_ERR_DEL_ISR     »Áπ˚œÎ¥”ISR÷–…æ≥˝ ¬º˛±Í÷æ◊È
              *                            OS_FLAG_INVALID_PGRP    »Áπ˚pgrp «“ª∏ˆø’÷∏’Î
              *                            OS_ERR_EVENT_TYPE      »Áπ˚√ª”–¥´µ›÷∏’ÎµΩ ¬º˛±Í÷æ◊È
              *                            OS_ERR_INVALID_OPT      ”–∑«∑®—°œÓ
              *                            OS_ERR_TASK_WAITING     “ª∏ˆªÚ∂‡∏ˆ»ŒŒÒ‘⁄ ¬º˛±Í÷æ◊È÷–µ»¥˝
              *∑µªÿ    : pevent        ”–¥Ì
              *              (OS_EVENT *)0 »Áπ˚≥…π¶…æ≥˝
              
                                                             
              *********************************************************************************************************
              */
              
              #if OS_FLAG_DEL_EN > 0
              OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR     cpu_sr;
              #endif
                  BOOLEAN       tasks_waiting;
                  OS_FLAG_NODE *pnode;
              
              
                  if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
                      *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
                      return (pgrp);//≤ª‘ –Ì¥”ISR÷–…æ≥˝
                  }
              #if OS_ARG_CHK_EN > 0
                  if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                      *err = OS_FLAG_INVALID_PGRP;
                      return (pgrp);//pgrp±ÿ–Î”––ß°£≤ªƒ‹Œ™¡„£¨≤¢÷∏œÚ ¬º˛±Í÷æ◊È
                  }
                  if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
                      *err = OS_ERR_EVENT_TYPE;
                      return (pgrp);//»Áπ˚≤ª « ¬º˛◊È¿‡–Õ
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  if (pgrp->OSFlagWaitList != (void *)0) {     /* See if any tasks waiting on event flags  */
                  // «∑Ò”–»ŒŒÒ‘⁄¥Àµ»¥˝£ø
                      tasks_waiting = TRUE;                              /* Yes                                      */
                  } else {//
                      tasks_waiting = FALSE;                             /* No                                       */
                  }
                  switch (opt) {
                      case OS_DEL_NO_PEND:    /* Delete group if no task waiting    */
                           //»Áπ˚√ª”–»ŒŒÒµ»¥˝≤≈…æ≥˝
                           if (tasks_waiting == FALSE) {//√ª”–»ŒŒÒµ»¥˝
                               pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;//Ω´À¸±Íº«Œ™Œ¥ π”√
                               pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
                       //Ω´∆‰∑µªÿµΩø’œ–¡¥±Ì÷–
                               OSFlagFreeList       = pgrp;
                               OS_EXIT_CRITICAL();
                               *err                 = OS_NO_ERR;//Œﬁ¥Ì
                               return ((OS_FLAG_GRP *)0);                /* Event Flag Group has been deleted        */
                           } else {//”–»ŒŒÒµ»¥˝
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 7   

                               OS_EXIT_CRITICAL();
                               *err                 = OS_ERR_TASK_WAITING;
                               return (pgrp);//∑µªÿ ¬º˛±Í÷æ◊È÷∏’Î
                           }
              
                      case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    //”–»ŒŒÒµ»¥˝“≤…æ≥˝
                           pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;//÷∏œÚ ¬º˛±Í÷æ÷–µ»¥˝»ŒŒÒΩ·µ„µƒ÷∏’Î
                           while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                      //æÕ–˜À˘”–µƒ»ŒŒÒ
                               OS_FlagTaskRdy(pnode, (OS_FLAGS)0);// π»ŒŒÒæÕ–˜£¨ ¬º˛∑¢…˙
                               pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;//÷ª“™≤ªŒ™¡„£¨æÕºÃ–¯÷∏œÚœ¬“ª∏ˆΩ·µ„°£ºÃ–¯æÕ–
             -˜
                           }
                           pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;//±Íº«Œ™Œ¥”√
                           pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
                           OSFlagFreeList       = pgrp;//Ω´∆‰∑µªÿµΩø’œ–¡¥±Ì
                           OS_EXIT_CRITICAL();
                           if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
                      //”–»ŒŒÒµ»¥˝µƒ«Èøˆœ¬£¨“™÷ÿ–¬»ŒŒÒµ˜∂»°£“ÚŒ™π“∆µƒ»ŒŒÒæÕ–˜¡À°£
                               OS_Sched();                               /* Find highest priority task ready to run  */
                           }
                           *err = OS_NO_ERR;//Œﬁ¥Ì
                           return ((OS_FLAG_GRP *)0);                    /* Event Flag Group has been deleted        */
              
                      default://∆‰À¸“Ï≥£«Èøˆ
                           OS_EXIT_CRITICAL();
                           *err = OS_ERR_INVALID_OPT;
                           return (pgrp);
                  }
              }
              #endif
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        WAIT ON AN EVENT FLAG GROUP
              *
              * Description: This function is called to wait for a combination of bits to be set in an event flag
              *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
              *
              * Arguments  : pgrp          is a pointer to the desired event flag group.
              *
              *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
              *                            The bits you want are specified by setting the corresponding bits in
              *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
              *                            'flags' would contain 0x03.
              *
              *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
              *                            You can specify the following argument:
              *
              *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
              *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
              *
              *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
              *                                  the call.  Example, to wait for any flag in a group AND then clear
              *                                  the flags that are present, set 'wait_type' to:
              *
              *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
              *
              *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 8   

              *                            desired bit combination.  If you specify 0, however, your task will wait
              *                            forever at the specified event flag group or, until a message arrives.
              *
              *              err           is a pointer to an error code and can be:
              *                            OS_NO_ERR              The desired bits have been set within the specified
              *                                                   'timeout'.
              *                            OS_ERR_PEND_ISR        If you tried to PEND from an ISR
              *                            OS_FLAG_INVALID_PGRP   If 'pgrp' is a NULL pointer.
              *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
              *                            OS_TIMEOUT             The bit(s) have not been set in the specified
              *                                                   'timeout'.
              *                            OS_FLAG_ERR_WAIT_TYPE  You didn't specify a proper 'wait_type' argument.
              *
              * Returns    : The new state of the flags in the event flag group when the task is resumed or,
              *              0 if a timeout or an error occurred.
              *
              * Called from: Task ONLY
                                                                       µ»¥˝ ¬º˛±Í÷æ◊Èµƒ ¬º˛±Í÷æŒª
              √Ë ˆ£∫»•ºÏ≤È ¬º˛±Í÷æ◊È÷–Ω·∫œŒªµƒ◊¥Ã¨ «÷√Œªªπ «±ª«Â≥˝£¨ƒ„ƒ‹
                              ºÏ≤È»Œ∫ŒΩ´±ª÷√ŒªªÚ’ﬂ«Â≥˝µƒŒªªÚ’ﬂ»´≤øŒª 
              ≤Œ ˝£∫pgrp£∫÷∏œÚƒø±Í ¬º˛±Í÷æ◊Èµƒ÷∏’Î
                              flags£∫ «“ª∏ˆŒªµƒƒ£ Ωœ‘ æ“™ºÏ≤ÈµƒŒª£¨±»»Á£∫ƒ„“™ºÏ≤‚0Œª∫Õ1Œª£¨ƒ«√¥ƒ„Ω´À¸
                                         …Ë÷√Œ™0x03
                              wait_type £∫±Íº«ƒ„œÎ»´≤øºÏ≤‚ªπ «÷ªœÎºÏ≤‚∆‰ µ“ª≤ø∑÷°£ƒ„ƒ‹±Íº«»Áœ¬≤Œ ˝£∫
              *                            OS_FLAG_WAIT_CLR_ALL   µ»¥˝À˘”–÷∏∂® ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æŒª«Â0
              *                            OS_FLAG_WAIT_CLR_ANY   µ»¥˝»Œ“‚“ª∏ˆ÷∏∂® ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æŒª÷√1
              *                            OS_FLAG_WAIT_SET_ALL   µ»¥˝À˘”–÷∏∂® ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æŒª÷√1
              *                            OS_FLAG_WAIT_SET_ANY  µ»¥˝»Œ“‚“ª∏ˆ÷∏∂® ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æŒª÷√1
                             »Áπ˚œÎ ¬º˛±Í÷æ±ªµ˜”√∫Ø ˝«Â≥˝µƒª∞£¨“™º”…œOS_FLAG_CONSUME£¨±»»Á£∫»Áπ˚
                             œÎ“™◊È”Î∫Û«Â≥˝£¨ƒ«√¥Ω´wait_type…Ë÷√≥…OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                             timeout:ƒ„µƒ»ŒŒÒµ»¥˝ƒø±ÍΩ·∫œŒª≥¨ ±£¨»Áπ˚ƒ„±Í÷æ¡„£¨ƒ„µƒ»ŒŒÒΩ´‘⁄÷∏∂®
                                        ¬º˛±Í÷æ◊È”¿æ√µ»¥˝÷±µΩ“ªÃıœ˚œ¢µΩ¿¥
                             err ÷∏œÚ¥ÌŒÛ¥˙¬Îµƒ÷∏’Î£¨ø…“‘Œ™£∫
              *                            OS_NO_ERR             ŒﬁŒÛ
              *                            OS_ERR_PEND_ISR       »Áπ˚œÎ¥”ISR÷–π“∆
              *                            OS_FLAG_INVALID_PGRP   »Áπ˚ 'pgrp'  «NULL÷∏’Î
              *                            OS_ERR_EVENT_TYPE      ƒ„√ª”–÷∏œÚ»ŒŒÒ ¬º˛øÿ÷∆◊È
              *                            OS_TIMEOUT             ‘⁄÷∏∂® ±º‰ƒ⁄Œª√ª”–±ª÷√Œª
              *                            OS_FLAG_ERR_WAIT_TYPE  ƒ„√ª”–÷∏∂®∫œ  µƒ 'wait_type' ≤Œ ˝
              
              ∑µªÿ£∫µ±»ŒŒÒºÃ–¯ ±£¨±Í÷æ»ŒŒÒ–¬◊¥Ã¨£¨¥ÌŒÛªÚ’ﬂ≥¨ ±∑µªÿ¡„
              ÷ªƒ‹¥”»ŒŒÒ÷–µ˜”√
              
              *********************************************************************************************************
              */
              
              OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR     cpu_sr;
              #endif
                  OS_FLAG_NODE  node;
                  OS_FLAGS      flags_cur;
                  OS_FLAGS      flags_rdy;
                  BOOLEAN       consume;
              
              
                  if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
                      *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
                      return ((OS_FLAGS)0);//≤ª‘ –Ì‘⁄÷–∂œ«∂Ã◊÷–µ˜”√±æ∫Ø ˝
                  }
              #if OS_ARG_CHK_EN > 0//‘ –ÌºÏ≤È∫Ø ˝≤Œ ˝
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 9   

                  if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                      *err = OS_FLAG_INVALID_PGRP;
                      return ((OS_FLAGS)0);//ø¥pgrp «≤ª «“ª∏ˆNULL÷∏’Î
                  }
                  if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
                      *err = OS_ERR_EVENT_TYPE;
                      return ((OS_FLAGS)0);//ø¥ «∑Ò÷∏œÚ ¬º˛±Í÷æ◊È ˝æ›Ω·ππ°£
                  }
              #endif
                  if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
              //ø¥ «∑Ò–Ë“™æ÷≤ø≤º∂˚±‰¡ø£¨OSFlagPend ‘ –Ì÷∏∂®‘⁄»ŒŒÒµ»¥˝ ¬º˛∑¢…˙∫Û£¨÷ÿ–¬
              //÷√ŒªªÚ«Â≥˝œ‡”¶µƒ ¬º˛±Í÷æŒª£¨∑Ω∑® «‘⁄µ˜”√¥À∫Ø ˝ ±£¨Ω´“ª∏ˆ≥£¡ø”Î≤Œ ˝
              //wait_typeœ‡º”
                      wait_type &= ~OS_FLAG_CONSUME;
                      consume    = TRUE;
                  } else {
                      consume    = FALSE;
                  }
              /*$PAGE*/
                  OS_ENTER_CRITICAL();
                  switch (wait_type) {
                      case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                           flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
              //»Áπ˚wait_typeŒ™OS_FLAG_WAIT_SET_ALLªÚ’ﬂOS_FLAG_WAIT_SET_AND ±£¨∫Ø ˝»°≥ˆ”…flags≤Œ ˝÷∏∂®
              //µƒ ¬º˛±Í÷æŒª
                           if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                //»Áπ˚»°≥ˆ±Í÷æŒª◊¥Ã¨«°∫√∑˚∫œ‘§∆⁄◊¥Ã¨£¨Àµ√˜»ŒŒÒ–Ë“™µ»¥˝µƒ ¬º˛±Í÷æŒª∂º“—æ≠÷√Œª
                //¥À«Èøˆœ¬£¨PEND∫Ø ˝¡¢º¥∑µªÿµ˜”√∫Ø ˝
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
                               }//∑µªÿ«∞ºÏ≤È «≤ª «“™Ω¯––«Â¡„≤Ÿ◊˜
                               flags_cur = pgrp->OSFlagFlags;            /* Will return the state of the group       */
                       //∑µªÿ◊È◊¥Ã¨
                               OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                       //ªÒ»° ¬º˛±Í÷æ◊Èµƒ–¬ ¬º˛±Í÷æ◊¥Ã¨÷µ£¨≤¢∑µªÿµ˜”√∫Ø ˝
                               *err      = OS_NO_ERR;
                               return (flags_cur);
                           } else {                                      /* Block task until events occur or timeout */
                           //»Áπ˚÷∏∂®µƒ ¬º˛±Í÷æŒª√ª”–ÕÍ»´÷√Œª£¨ƒ«√¥µ˜”√∫Ø ˝Ω´π“∆
                           //÷±µΩ≥¨ ±ªÚ’ﬂ ¬º˛¿¥µΩ
                               OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
                               OS_EXIT_CRITICAL();
                           }
                           break;
              
                      case OS_FLAG_WAIT_SET_ANY:
                           flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
                     //»Áπ˚∏’∫√ «Œ“√«“™µƒŒª£¨µ»¥˝≤Ÿ◊˜¡¢º¥Ω· ¯£¨∑µªÿµ˜”√∫Ø ˝
                           if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
                               }// «∑Ò–Ë“™«Â≥˝£ø
                               flags_cur = pgrp->OSFlagFlags;            /* Will return the state of the group       */
                       //ªÒ»° ¬º˛±Í÷æ◊È–¬µƒ◊¥Ã¨£¨≤¢∑µªÿµ˜”√∫Ø ˝
                               OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                               *err      = OS_NO_ERR;
                               return (flags_cur);
                           } else {                                      /* Block task until events occur or timeout */
                               OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
                               OS_EXIT_CRITICAL();
                           }//»Áπ˚À˘”–∂º√ª”–÷√Œª£¨‘ÚΩ´µ˜”√∫Ø ˝π“∆£¨÷±µΩ ¬º˛¿¥µΩªÚ’ﬂ≥¨ ±
                           break;
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 10  

              
              #if OS_FLAG_WAIT_CLR_EN > 0
                      case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                           flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
                           if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
                               }
                               flags_cur = pgrp->OSFlagFlags;            /* Will return the state of the group       */
                               OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                               *err      = OS_NO_ERR;
                               return (flags_cur);
                           } else {                                      /* Block task until events occur or timeout */
                               OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
                               OS_EXIT_CRITICAL();
                           }
                           break;
              
                      case OS_FLAG_WAIT_CLR_ANY:
                           flags_rdy = ~pgrp->OSFlagFlags & flags;       /* Extract only the bits we want            */
                           if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
                               if (consume == TRUE) {                    /* See if we need to consume the flags      */
                                   pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
                               }
                               flags_cur = pgrp->OSFlagFlags;            /* Will return the state of the group       */
                               OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                               *err      = OS_NO_ERR;
                               return (flags_cur);
                           } else {                                      /* Block task until events occur or timeout */
                               OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
                               OS_EXIT_CRITICAL();
                           }
                           break;
              #endif
              
                      default://∆‰À¸«Èøˆ
                           OS_EXIT_CRITICAL();
                           flags_cur = (OS_FLAGS)0;
                           *err      = OS_FLAG_ERR_WAIT_TYPE;//¥ÌŒÛµƒµ»¥˝¿‡–Õ
                           return (flags_cur);
                  }
                  OS_Sched();   /* Find next HPT ready to run  *///os_FlagBlock()∑µªÿ ±£¨ª·Ω¯––»ŒŒÒµ˜∂»
                  // «“ÚŒ™µ˜”√¥À»ŒŒÒµƒ∫Ø ˝“ÚŒ™ ¬º˛√ª”–∑¢…˙∂¯≤ªƒ‹ºÃ–¯‘À––
                  OS_ENTER_CRITICAL();
                  if (OSTCBCur->OSTCBStat & OS_STAT_FLAG) {              /* Have we timed-out?                       */
                      OS_FlagUnlink(&node);//≥¨ ±¡À¬£ø»Áπ˚≥¨ ±£¨æÕ¥”À´œÚµ»¥˝¡–±Ì÷–…æ≥˝
                      OSTCBCur->OSTCBStat = OS_STAT_RDY;/* Yes, make task ready-to-run   */
                  //≥¨ ±æÕ π»ŒŒÒΩ¯»ÎæÕ–˜◊¥Ã¨
                      OS_EXIT_CRITICAL();
                      flags_cur           = (OS_FLAGS)0;
                      *err                = OS_TIMEOUT;                  /* Indicate that we timed-out waiting       */
                  //∑µªÿ£∫Œ“√«≥¨ ±¿≤£°
                  } else {//»Áπ˚√ª”–≥¨ ±£¨“ª∂® «∞¥’’‘§∆⁄µƒ∑¢…˙¡À
                      if (consume == TRUE) {         /* See if we need to consume the flags      */
                    // «∑Ò“™«Â≥˝≤Œ ˝
                          switch (wait_type) {
                              case OS_FLAG_WAIT_SET_ALL:
                              case OS_FLAG_WAIT_SET_ANY:                 /* Clear ONLY the flags we got              */
                        //÷ª«Â≥˝Œ“√«µ√µΩµƒ°£
                                   pgrp->OSFlagFlags &= ~OSTCBCur->OSTCBFlagsRdy;
                                   break;
              
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 11  

              #if OS_FLAG_WAIT_CLR_EN > 0
                              case OS_FLAG_WAIT_CLR_ALL:
                              case OS_FLAG_WAIT_CLR_ANY:                 /* Set   ONLY the flags we got              */
                        //÷ª÷√ŒªŒ“√«µ√µΩµƒ°£
                                   pgrp->OSFlagFlags |= OSTCBCur->OSTCBFlagsRdy;
                                   break;
              #endif
                          }
                      }
                      flags_cur = pgrp->OSFlagFlags;//¥À∫Ø ˝ªÒ»° ¬º˛±Í÷æ◊Èµƒµ±«∞ ¬º˛±Í÷æ◊¥Ã¨£¨
                      //≤¢∑µªÿ∏¯µ˜”√◊¥Ã¨
                      OS_EXIT_CRITICAL();
                      *err      = OS_NO_ERR;  /* Event(s) must have occurred              */
                  }
                  return (flags_cur);
              }
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                         POST EVENT FLAG BIT(S)
              *
              * Description: This function is called to set or clear some bits in an event flag group.  The bits to
              *              set or clear are specified by a 'bit mask'.
              *
              * Arguments  : pgrp          is a pointer to the desired event flag group.
              *
              *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
              *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
              *                            and 5 you would set 'flags' to:
              *
              *                                0x31     (note, bit 0 is least significant bit)
              *
              *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
              *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
              *                            4 and 5 you would specify 'flags' as:
              *
              *                                0x31     (note, bit 0 is least significant bit)
              *
              *              opt           indicates whether the flags will be:
              *                                set     (OS_FLAG_SET) or
              *                                cleared (OS_FLAG_CLR)
              *
              *              err           is a pointer to an error code and can be:
              *                            OS_NO_ERR              The call was successfull
              *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer
              *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
              *                            OS_FLAG_INVALID_OPT    You specified an invalid option
              *
              * Returns    : the new value of the event flags bits that are still set.
              *
              * Called From: Task or ISR
              *
              * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
              *                 flag group.
              *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
              *                 the event flag group.
                                                              ÷√ŒªªÚ«Â0 ¬º˛±Í÷æ◊È÷–µƒ ¬º˛±Í÷æ
              √Ë ˆ£∫¥À∫Ø ˝…Ë÷√ªÚ«Â≥˝ ¬º˛±Í÷æ◊È÷–µƒ“ª–©Œª£¨Õ®π˝…Ë÷√—⁄¬Î¿¥ÕÍ≥…°£
              ≤Œ ˝£∫pgrp£∫ƒø±Í ¬º˛±Í÷æ◊È÷∏’Î
                              flags£∫»Áπ˚opt «OS_FLAG_SET£¨flags÷–µƒ√ø“ªŒªΩ´…Ë÷√ ¬º˛±Í÷æ◊È÷–µƒ∂‘”¶Œª°£
                              »Á£∫“™…Ë÷√0°¢4°¢5Œª£¨ƒ«√¥flagsŒ™0x31°£»Áπ˚'opt' (see below)  « OS_FLAG_CLR£¨ƒ«√¥
                              flags÷–µƒ√ø“ªŒª÷√ŒªΩ´«Â≥˝ ¬º˛±Í÷æ◊È÷–µƒ∂‘”¶Œª°£
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 12  

                              »Á£∫«Â≥˝0°¢4°¢5Œª£¨ƒ«√¥flagsŒ™0x31°£
              *              opt          œ‘ æflags «∑ÒŒ™£∫
              *                                set     (OS_FLAG_SET) ªÚ’ﬂ
              *                                cleared (OS_FLAG_CLR)
              *
              *              err           is a pointer to an error code and can be:
              *                            OS_NO_ERR              ≥…π¶
              *                            OS_FLAG_INVALID_PGRP   ƒ„¥´µ›¡Àø’÷∏’Î
              *                            OS_ERR_EVENT_TYPE     √ª”–÷∏œÚ ¬º˛±Í÷æ◊È
              *                            OS_FLAG_INVALID_OPT    ”–¥ÌŒÛ—°œÓ
              *********************************************************************************************************
              */
              OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
                  OS_CPU_SR     cpu_sr;
              #endif
                  OS_FLAG_NODE *pnode;
                  BOOLEAN       sched;
                  OS_FLAGS      flags_cur;
                  OS_FLAGS      flags_rdy;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                      *err = OS_FLAG_INVALID_PGRP;
                      return ((OS_FLAGS)0);//pgrp «∑Ò∫œ¿Ì
                  }
                  if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
                      *err = OS_ERR_EVENT_TYPE;
                      return ((OS_FLAGS)0);//±£÷§ «÷∏œÚ ¬º˛±Í÷æ◊È
                  }
              #endif
              /*$PAGE*/
                  OS_ENTER_CRITICAL();
                  switch (opt) {
                      case OS_FLAG_CLR://»Áπ˚ «∏∫∑¥¿°£¨…Ë÷√œ‡∑¥œÓ
                           pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
                           break;
              
                      case OS_FLAG_SET://»Áπ˚ «’˝∑¥¿°£¨…Ë÷√œ‡Õ¨œÓ
                           pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
                           break;
              
                      default://”–“Ï≥£œ÷œÛ
                           OS_EXIT_CRITICAL();                     /* INVALID option                                 */
                           *err = OS_FLAG_INVALID_OPT;
                           return ((OS_FLAGS)0);
                  }
                  sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
                //≥ı ºªØºŸ…Ë≤ªª·µº÷¬∏¸∏ﬂ”≈œ»º∂»ŒŒÒΩ¯»ÎæÕ–˜Ã¨£¨À˘“‘≤ª–Ë“™µ˜∂»
                  pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;//»°≥ˆµ»¥˝¡–±Ì÷–µƒµ⁄“ª∏ˆΩ·µ„
                  while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                  //»Áπ˚”–»ŒŒÒµ»¥˝£¨±È¿˙ ¬º˛±Í÷æ÷–À˘”–»ŒŒÒ
                      switch (pnode->OSFlagNodeWaitType) {//µ»¥˝µƒ¿‡–Õ « ≤√¥
                          case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                               flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
                               if (flags_rdy == pnode->OSFlagNodeFlags) {//»Áπ˚ÕÍ»´∫Õ»ŒŒÒµ»¥˝µƒ ¬º˛±Í÷æŒª¬˙◊„£¨
                                   if (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE) { /* Make task RTR, event(s) Rx'd   */
                          //ƒ«√¥ π»ŒŒÒΩ¯»ÎæÕ–˜◊¥Ã¨
                                       sched = TRUE;                               /* When done we will reschedule   */
                          //≤¢≤ª «√øºÏ≤È“ª∏ˆOSFLAG_NODEæÕΩ¯––“ª¥Œ»ŒŒÒµ˜∂»£¨∂¯ «‘⁄±È¿˙ÕÍ»´≤øµ»¥˝»ŒŒÒ∫Û
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 13  

                          //Ω¯––“ª¥Œ◊‹µƒ»ŒŒÒµ˜∂»°£
                                   }
                               }
                               break;
              
                          case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                      //»Œ“‚“ª∏ˆ÷∏∂® µƒ ¬º˛±Í÷æŒª÷√Œª
                               flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
                               if (flags_rdy != (OS_FLAGS)0) {//÷ª“™≤ªŒ™¡„£®”–ŒªæÕ––£©æÕ÷¥––
                                   if (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE) { /* Make task RTR, event(s) Rx'd   */
                                       sched = TRUE;                               /* When done we will reschedule   */
                                   }
                               }
                               break;
              
              #if OS_FLAG_WAIT_CLR_EN > 0
                          case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                      //÷∏∂® ¬º˛±Í÷æ»´≤ø«Â¡„
                               flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
                               if (flags_rdy == pnode->OSFlagNodeFlags) {
                                   if (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE) { /* Make task RTR, event(s) Rx'd   */
                                       sched = TRUE;                               /* When done we will reschedule   */
                                   }
                               }
                               break;
              
                          case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                      //»Œ“‚“ª∏ˆ÷∏∂®µƒ ¬º˛±Í÷æ«Â¡„
                               flags_rdy = ~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
                               if (flags_rdy != (OS_FLAGS)0) {
                                   if (OS_FlagTaskRdy(pnode, flags_rdy) == TRUE) { /* Make task RTR, event(s) Rx'd   */
                                       sched = TRUE;                               /* When done we will reschedule   */
                                   }
                               }
                               break;
              #endif
                      }
                      pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
                  //Õ®π˝À´œÚ¡¥±Ìµ√µΩœ¬“ª∏ˆOSFlagNode
              
                  }
                  OS_EXIT_CRITICAL();
                  if (sched == TRUE) {
                  //»Áπ˚≤º∂˚±‰¡øŒ™’Ê£¨Ω¯––»ŒŒÒµ˜∂»
                      OS_Sched();
                  }
                  OS_ENTER_CRITICAL();
                  flags_cur = pgrp->OSFlagFlags;//∑µªÿµ±«∞ ¬º˛±Í÷æ◊Èµƒ ¬º˛±Í÷æ◊¥Ã¨
                  OS_EXIT_CRITICAL();
                  *err      = OS_NO_ERR;
                  return (flags_cur);
              }
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                           QUERY EVENT FLAG
              *
              * Description: This function is used to check the value of the event flag group.
              *
              * Arguments  : pgrp         is a pointer to the desired event flag group.
              *
              *              err           is a pointer to an error code returned to the called:
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 14  

              *                            OS_NO_ERR              The call was successfull
              *                            OS_FLAG_INVALID_PGRP   You passed a NULL pointer
              *                            OS_ERR_EVENT_TYPE      You are not pointing to an event flag group
              *
              * Returns    : The current value of the event flag group.
              *
              * Called From: Task or ISR
                                                                       ≤È—Ø ¬º˛±Í÷æ◊Èµƒ◊¥Ã¨
              √Ë ˆ£∫”√”⁄≤È—Ø ¬º˛±Í÷æ◊Èµƒ◊¥Ã¨
              ≤Œ ˝£∫ pgrp£∫÷∏œÚƒø±Í ¬º˛±Í÷æ◊Èµƒ◊¥Ã¨
                                err£∫∑µªÿ∏¯µ˜”√∫Ø ˝µƒ≥ˆ¥Ì¥˙¬Î÷∏’Î£∫
              *                            OS_NO_ERR              µ˜”√≥…π¶
              *                            OS_FLAG_INVALID_PGRP   ƒ„¥´µ›¡Àø’÷∏’Î
              *                            OS_ERR_EVENT_TYPE      ƒ„√ª”–÷∏œÚ“ª∏ˆ ¬º˛±Í÷æ◊È                    
              *********************************************************************************************************
              */
              
              #if OS_FLAG_QUERY_EN > 0//∞¸∫¨ OSFlagQuery()¥˙¬Î
              OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_FLAGS   flags;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                      *err = OS_FLAG_INVALID_PGRP;
                      return ((OS_FLAGS)0);//≤ª∫œ¿Ìµƒpgrp
                  }
                  if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
                      *err = OS_ERR_EVENT_TYPE;
                      return ((OS_FLAGS)0);//≤ª « ¬º˛±Í÷æ¿‡–Õ
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  flags = pgrp->OSFlagFlags;//ªÒ»°µ±«∞ ¬º˛±Í÷æµƒ◊¥Ã¨
                  OS_EXIT_CRITICAL();
                  *err = OS_NO_ERR;
                  return (flags);      /* Return the current value of the event flags       */
                //∑µªÿ◊¥Ã¨±Í÷æ∏¯µ˜”√∫Ø ˝
              }
              #endif
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
              *
              * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
              *              event flag bit(s) are set.
              *
              * Arguments  : pgrp          is a pointer to the desired event flag group.
              *
              *              pnode         is a pointer to a structure which contains data about the task waiting for
              *                            event flag bit(s) to be set.
              *
              *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
              *                            The bits you want are specified by setting the corresponding bits in
              *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
              *                            'flags' would contain 0x03.
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 15  

              *
              *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
              *                            to be set/cleared.
              *                            You can specify the following argument:
              *
              *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
              *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
              *
              *              timeout       is the desired amount of time that the task will wait for the event flag
              *                            bit(s) to be set.
              *
              * Returns    : none
              *
              * Called by  : OSFlagPend()  OS_FLAG.C
              *
              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                                                         π“∆»ŒŒÒ÷±µΩ ¬º˛±Í÷æ¿¥µΩªÚ’ﬂ≥¨ ±
              √Ë ˆ£∫À¸ «“ª∏ˆucosƒ⁄≤ø∫Ø ˝£¨Ω´“ª∏ˆ»ŒŒÒÀØ√ﬂ÷±µΩƒø±Í±Í÷æŒª÷√Œª
              ≤Œ ˝£∫pgrp£∫÷∏œÚƒø±Í ¬º˛øÿ÷∆øÈµƒ÷∏’Î
                               pnode£∫÷∏œÚµ»¥˝ ¬º˛±Í÷æŒª÷√Œªµƒ»ŒŒÒµƒ ˝æ›µƒΩ·ππ÷∏’Î
                               flags£∫ «“ª∏ˆŒªƒ£ Ω£¨∞¸∫¨œÎºÏ—ÈµƒŒª£¨Õ®π˝…Ë÷√flags÷–œ‡”¶Œª¿¥…Ë÷√ƒ„œÎ“™
                                           µƒŒª°£±»»Á£∫»Áπ˚”¶”√÷–œÎµ»¥˝0∫Õ1Œª£¨ƒ«√¥flagsæÕŒ™0x03°£
                               wait_type£∫±Í÷æƒ„œÎÀ˘”–Œª…Ë÷√/«Â¡„ªπ «»Œ∫ŒŒª…Ë÷√/«Â¡„
                               ƒ„ø…“‘…Ë≥…“‘œ¬≤Œ ˝£∫
              *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
              *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
              *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                               timeout£∫»ŒŒÒµ»¥˝ ¬º˛±Í÷æŒªµƒƒø±Í ±º‰
              *********************************************************************************************************
              */
              
              static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16
             -U timeout)
              {
                  OS_FLAG_NODE  *pnode_next;
              
              
                  OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
                  OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
                //‘⁄TCB÷–±£¥Ê≥¨ ± ±º‰
              #if OS_TASK_DEL_EN > 0//‘ –Ì∞¸∫¨»ŒŒÒ…æ≥˝¥˙¬Î
                  OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
              //  Ω´OSTCBFlagNode ˝æ›Ω·ππ±£¥Ê‘⁄TCBµƒ“ª∏ˆ¡¥Ω”÷–£¨«∞Ã· «OS_TASK_DEL_ENŒ™1£¨ø…“‘∏˘æ›’‚∏ˆ
              //¡¥Ω”∞—“™…æ≥˝µƒ»ŒŒÒ¥”∂‘”¶µƒ ¬º˛±Í÷æ◊Èµƒµ»¥˝¡–±Ì÷–…æ≥˝°£…æ≥˝π§◊˜”…∆‰À¸∫Ø ˝ÕÍ≥…°£
              #endif
                  pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
              //±£¥Ê»ŒŒÒµ»¥˝±Í÷æ◊È÷–÷∏∂® ¬º˛±Í÷æŒª∫Õµ»¥˝∑Ω Ωµƒ–≈œ¢£¨
                  pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
              //±£¥ÊŒ“√«µ»¥˝µƒ∑Ω Ω 
                  pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
              //Ω´µ±«∞»ŒŒÒ¡–»Îµ»¥˝ ¬º˛µƒTCB
                  pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
              //∞—–¬‘ˆµƒOS_FLAG_NODEµƒÃÌº”µΩÀ´œÚ¡¥±Ìµƒø™ º∂À
                  pnode->OSFlagNodePrev     = (void *)0;
                  pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
                //Ω´¥À ¬º˛±Í÷æ◊È∑¥œÚ¡¥Ω”µΩOS_FLAG_NODEµƒ ¬º˛±Í÷æ◊È÷–£¨µ±…æ≥˝“ª∏ˆ»ŒŒÒ ±£¨
                //–Ë“™∏˘æ›’‚∏ˆ¡¥Ω”∞—±ª…æ≥˝µƒ»ŒŒÒ¥”∂‘”¶µƒ ¬º˛±Í÷æ◊Èµƒµ»¥˝»ŒŒÒ¡–±Ì÷–…æ≥˝
                  pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
                //∞—«∞√Ê“ª∏ˆOS_FLAG_NODE÷∏’Î¡¥Ω”µΩ–¬ÃÌº”µƒOS_FLAG_NODE
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 16  

                  if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
                      pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
                  }
                  pgrp->OSFlagWaitList = (void *)pnode;//µ⁄“ª∏ˆΩ·µ„æÕ±‰≥…pnode¡À
                                                                    /* Suspend current task until flag(s) received   */
                  if ((OSRdyTbl[OSTCBCur->OSTCBY] &= ~OSTCBCur->OSTCBBitX) == 0) {
                      OSRdyGrp &= ~OSTCBCur->OSTCBBitY;//π“∆µ±«∞»ŒŒÒ÷±µΩ ’µΩ ¬º˛±Í÷æ
                  }
              }
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                    INITIALIZE THE EVENT FLAG MODULE
              *
              * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
              *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
              *
              * Arguments  : none
              *
              * Returns    : none
              *
              * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                                                                  ≥ı ºªØ ¬º˛±Í÷æƒ£–Õ
              √Ë ˆ£∫”…ucosµ˜”√≥ı ºªØ ¬º˛±Í÷æƒ£øÈ£¨”¶”√≥Ã–Ú≤ªƒ‹µ˜”√
              ≤Œ ˝£∫Œﬁ
              ∑µªÿ£∫Œﬁ
              ±∏◊¢£∫ «ƒ⁄≤ø∫Ø ˝£¨”¶”√≥Ã–Ú≤ªƒ‹µ˜”√
              *********************************************************************************************************
              */
              
              void  OS_FlagInit (void)
              {
              #if OS_MAX_FLAGS == 1//÷ª”–“ª∏ˆ ¬º˛±Í÷æ◊È
                  OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
              //÷ª”–“ª∏ˆ◊È
                  OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
              //≥ı ºªØ…Ë÷√≥…√ª”– π”√
                  OSFlagFreeList->OSFlagWaitList = (void *)0;
              //√ª”–»ŒŒÒ‘⁄µ»À¸
              #endif
              
              #if OS_MAX_FLAGS >= 2//∂‡∏ˆ ¬º˛±Í÷æ◊È
                  INT8U        i;
                  OS_FLAG_GRP *pgrp1;
                  OS_FLAG_GRP *pgrp2;
              
              
                  pgrp1 = &OSFlagTbl[0];
                  pgrp2 = &OSFlagTbl[1];
                  for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
                  //≥ı ºªØø’œ–µƒ ¬º˛±Í÷æ
                      pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;//…Ë÷√≥…√ª”– π”√
                      pgrp1->OSFlagWaitList = (void *)pgrp2;//∞—À¸√«¡¥∆¿¥
                      pgrp1++;
                      pgrp2++;
                  }
                  pgrp1->OSFlagWaitList = (void *)0;//√ª”–»ŒŒÒµ»À¸√«
                  OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];//±ÌÕ∑
              #endif
              }
              
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 17  

              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
              *
              * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
              *              desired event flag bits have been set.
              *
              * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
              *                            event flag bit(s) to be set.
              *
              *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
              *                            ready-to-run.
              *
              * Returns    : none
              *
              * Called by  : OSFlagsPost() OS_FLAG.C
              *
              * Note(s)    : 1) This function assumes that interrupts are disabled.
              *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                                                       // ¬º˛∑¢…˙£¨ π»ŒŒÒæÕ–˜
              √Ë ˆ£∫Ucosƒ⁄≤ø∫Ø ˝£¨”√”⁄ƒø±Í ¬º˛±Í÷æŒª÷√Œª¡À£¨ π»ŒŒÒæÕ–˜
              ≤Œ ˝£∫pnode£∫÷∏œÚ∞¸∫¨µ»¥˝ ¬º˛±Í÷æŒª÷√Œªµƒ»ŒŒÒ ˝æ›µƒ÷∏’Î
                               flags_rdy£∫∞¸∫¨ ¬º˛±Í÷æµƒŒªƒ£ Ω£¨À¸Ω´“˝∆ ¬º˛æÕ–˜
              ∑µªÿ£∫Œﬁ
              ”…OSFlagsPost() OS_FLAG.Cµ˜”√
              ±∏◊¢£∫1°¢µ˜”√¥À∫Ø ˝“™πÿ÷–∂œ
                               2°¢ƒ⁄≤ø∫Ø ˝£¨”¶”√≥Ã–Ú≤ªƒ‹µ˜”√
              *********************************************************************************************************
              */
              
              static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
              {
                  OS_TCB   *ptcb;
                  BOOLEAN   sched;
              
              
                  ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
                //»°≥ˆ÷∏œÚµ»¥˝ ¬º˛µƒPCB÷∏’Î
                  ptcb->OSTCBDly      = 0;//≤ª—” ±
                  ptcb->OSTCBFlagsRdy = flags_rdy;//Ω´–Ë“™æÕ–˜»ŒŒÒµƒ±Í÷æ»°≥ˆ¿¥
                  ptcb->OSTCBStat    &= ~OS_STAT_FLAG;//œ˚≥˝ ¬º˛±Í÷æ◊È÷–π“∆◊¥Ã¨
                  if (ptcb->OSTCBStat == OS_STAT_RDY) {      /* Put task into ready list                 *///ΩªÀ¸∑≈»ÎæÕ–
             -˜¡–±Ì
                      OSRdyGrp               |= ptcb->OSTCBBitY;
                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;//º”»ÎæÕ–˜¡–±Ì£¨æﬂÃÂÀ„∑®º˚BLOG
                      sched                   = TRUE;//–Ë“™»ŒŒÒµ˜∂»
                  } else {//∑Ò‘Ú≤ª–Ë“™»ŒŒÒµ˜∂»
                      sched                   = FALSE;
                  }
                  OS_FlagUnlink(pnode);//Ω´Ω·µ„¥”µ»¥˝¡–±Ì÷–…æ≥˝
                  return (sched);
              }
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
              *
              * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
              *              list of tasks waiting for the event flag.
              *
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 18  

              * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
              *                            event flag bit(s) to be set.
              *
              * Returns    : none
              *
              * Called by  : OS_FlagTaskRdy() OS_FLAG.C
              *              OSFlagPend()     OS_FLAG.C
              *              OSTaskDel()      OS_TASK.C
              *
              * Note(s)    : 1) This function assumes that interrupts are disabled.
              *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
              *********************************************************************************************************
              */
              /*
              *********************************************************************************************************
                                                                   Ω´ ¬º˛±Í÷æΩ·µ„¥”µ»¥˝¡–±Ì÷–…æ≥˝
              √Ë ˆ£∫’‚∏ˆ∫Ø ˝ «ucosƒ⁄≤øµƒ£¨”√”⁄Ω´ ¬º˛±Í÷æΩ·µ„∫Õµ»¥˝ ¬º˛±Í÷æµƒ“ªœµ¡–»ŒŒÒΩ‚¡¥°£
              ≤Œ ˝£∫pnode:À¸ «“ª∏ˆΩ·ππ÷∏’Î£¨∞¸∫¨»ŒŒÒµ»¥˝ ¬º˛±Í÷æŒªΩ´±ª…Ë÷√µƒ ˝æ›°£
              ∑µªÿ£∫Œﬁ
                 ”…œ¬√Ê∫Ø ˝µ˜”√£∫ OS_FlagTaskRdy() OS_FLAG.C
              *                                               OSFlagPend()     OS_FLAG.C
              *                                               OSTaskDel()      OS_TASK.C
              ±∏◊¢£∫1°¢’‚∏ˆ∫Ø ˝ºŸ∂®÷–∂œ≤ªƒ‹ π
                              2°¢¥À∫Ø ˝ Ù”⁄ucosƒ⁄≤ø£¨”¶”√∫Ø ˝≤ªƒ‹µ˜”√°£
              
              *********************************************************************************************************
              */
              
              
              void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
              {
              #if OS_TASK_DEL_EN > 0//‘ –Ì ∞¸∫¨»ŒŒÒ…æ≥˝¥˙¬Î
                  OS_TCB       *ptcb;//»ŒŒÒøÿ÷∆øÈ
              #endif
                  OS_FLAG_GRP  *pgrp;// ¬º˛øÿ÷∆»∫
                  OS_FLAG_NODE *pnode_prev;// ¬º˛±Í÷æµ»¥˝¡¥±ÌΩ”µ„«∞∂À
                  OS_FLAG_NODE *pnode_next;// ¬º˛±Í÷æµ»¥˝¡¥±ÌΩ”µ„∫Û∂À
              
              
                  pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;//µ»¥˝¡¥±Ì÷–µ»¥˝Ω·µ„÷∏’Î«∞∂À∏≥∏¯pnode_prev
                  pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;//µ»¥˝¡¥±Ì÷–µ»¥˝Ω·µ„÷∏’Î∫Û∂À∏≥∏¯pnode_next
                  if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
                  //»Áπ˚ «µ⁄“ª∏ˆΩ·µ„
                      pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
                  //µ»¥˝¡¥±Ì÷– ¬º˛øÿ÷∆»∫÷∏’Î∏≥∏¯ ¬º˛øÿ÷∆»∫
                      pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
                  // ¬º˛øÿ÷∆»∫÷–œ¬“ª∏ˆ÷∏’Î÷√”⁄µ»¥˝¡¥±Ìµƒµ⁄“ª∏ˆΩ·µ„÷∏’Î
                      if (pnode_next != (OS_FLAG_NODE *)0) {
                          pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
                    //–¬Ω·µ„µƒ«∞∂À÷∏œÚø’÷∏’Î
                      }
                  } else {                                                    /* No,  A node somewhere in the list   */
                  //»Áπ˚≤ª «µ⁄“ª∏ˆΩ·µ„    
                      pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
                //«∞∂Àµƒ∫Û∂ÀŒ™pnode_next
                      if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
                    //»Áπ˚≤ª « «∫Û“ª∏ˆΩ·µ„
                          pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
                    //∫Û∂Àµƒ«∞∂ÀŒ™pnodeµƒ«∞∂À
                      }
                  }
              #if OS_TASK_DEL_EN > 0//ƒ‹±„…æ≥˝»ŒŒÒ¥˙¬Î
C51 COMPILER V9.56.0.0   OS_FLAG                                                           10/21/2017 15:51:50 PAGE 19  

                  ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;//µ»¥˝»ŒŒÒøÿ÷∆øÈ÷∏’Î∏≥∏¯»ŒŒÒøÿ÷∆øÈ
                  ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;// ¬º˛±Í÷æΩ·µ„«Â¡„
              #endif
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
