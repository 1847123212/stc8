C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE OS_Q
OBJECT MODULE PLACED IN .\OUTPUT\OS_Q.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\uCOSII\OS_Q.C LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\LIST\OS_Q.lst) TABS(2) OBJECT(.\OUTPUT\OS_Q.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                        MESSAGE QUEUE MANAGEMENT
   6          *
   7          *                          (c) Copyright 1992-2002, Jean J. Labrosse, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File : OS_Q.C
  11          * By   : Jean J. Labrosse
  12          *********************************************************************************************************
  13          */
  14          
  15          #ifndef  OS_MASTER_FILE//·ÀÖ¹±àÒëÆ÷°üº¬Ò»Ð©´úÂë
  16          #include "..\APP\includes.h"
  17          #endif
  18          
  19          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
              /*
              *********************************************************************************************************
              *                                      ACCEPT MESSAGE FROM QUEUE
              *
              * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
              *              OSQAccept() does not suspend the calling task if a message is not available.
              *
              * Arguments  : pevent        is a pointer to the event control block
              *
              * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
              *                            from the so the next time OSQAccept() is called, the queue will contain
              *                            one less entry.
              *              == (void *)0  if the queue is empty or,
              *                            if 'pevent' is a NULL pointer or,
              *                            if you passed an invalid event type
              
              *********************************************************************************************************
              */
              
              #if OS_Q_ACCEPT_EN > 0
              void  *OSQAccept (OS_EVENT *pevent)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  void      *msg;
                  OS_Q      *pq;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                      return ((void *)0);
                  }
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
                      return ((void *)0);
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 2   

                  }
              #endif
                  OS_ENTER_CRITICAL();
                  pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
                  if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
                      msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
                      pq->OSQEntries--;                        /* Update the number of entries in the queue          */
                      if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
                          pq->OSQOut = pq->OSQStart;
                      }
                  } else {
                      msg = (void *)0;                         /* Queue is empty                                     */
                  }
                  OS_EXIT_CRITICAL();
                  return (msg);                                /* Return message received (or NULL)                  */
              }
              #endif
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        CREATE A MESSAGE QUEUE
              *
              * Description: This function creates a message queue if free event control blocks are available.
              *
              * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
              *                            storage area MUST be declared as an array of pointers to 'void' as follows
              *
              *                            void *MessageStorage[size]
              *
              *              size          is the number of elements in the storage area
              *
              * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
              *                                created queue
              *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                                                                    ½¨Á¢Ò»¸öÏûÏ¢¶ÓÁÐ
              ÃèÊö£ºÈç¹ûÓÐ¿ÕÓàÊÂ¼þ¿ØÖÆ¿é£¬¾Í½¨Á¢Ò»¸öÏûÏ¢¶ÓÁÐ
              ²ÎÊý£ºstart£ºÖ¸ÏòÏûÏ¢¶ÓÁÐ´æ´¢¿Õ¼ä»ùµØÖ·¡£´æ´¢¿Õ¼ä±ØÐë¶¨Òå³Évoid ÐÍµÄ
                                          Ò»ÏµÁÐÖ¸Õë£¬ÐÎÊ½ÈçÓÒ£ºvoid *MessageStorage[size]
                               size£º´æ´¢¿Õ¼äÄÚµ¥ÔªµÄÊýÄ¿
              ·µ»Ø£º!= (OS_EVENT *)0  ÊÇÖ¸Ïò½áºÏ½¨Á¢µÄ¶ÓÁÐµÄÊÂ¼þ¿ØÖÆÊ±ÖÓ(OS_EVENT)µÄÖ¸Õë
                               == (OS_EVENT *)0Èç¹ûÃ»ÓÐÊÊºÏµÄÊÂ¼þ¿ØÖÆ¿é»òÕßÓÐ´íÎó
              *********************************************************************************************************
              */
              
              OS_EVENT  *OSQCreate (void **start, INT16U size)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;//·ÖÅäÃûÎªcpu_sr µÄ¾Ö²¿±äÁ¿£¬ÓÃÓÚÖ§³ÖOS_CRITICAL_METHOD·½·¨3
              #endif
                  OS_EVENT  *pevent;
                  OS_Q      *pq;
              
              
                  if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
                      return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
                  }//²»ÄÜÔÚISRÖÐ½¨Á¢ÏûÏ¢¶ÓÁÐ
                  OS_ENTER_CRITICAL();
                  pevent = OSEventFreeList;                    /* Get next free event control block                  */
                //´Ó¿ÕÓàµÄECBÁ´±íÖÐÈ¡µÃÒ»¸öÊÂ¼þ¿ØÖÆ¿é¡£¶ÔÊ£ÏÂµÄ×÷ÏàÓ¦µ÷Õû
                //ECBÊÇµ¥ÏòÁ´±í
                  if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
                      OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 3   

                  }//¶ÔÊ£ÏÂµÄ½øÐÐÏàÓ¦µÄµ÷Õû
                  OS_EXIT_CRITICAL();
                  if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
                  //Èç¹ûÎÒÃÇµÃµ½ÁËÊÂ¼þ¿ØÖÆ¿é
                      OS_ENTER_CRITICAL();
                      pq = OSQFreeList;                        /* Get a free queue control block                     */
                  //µÃµ½Ò»¿éÐÂµÄ¶ÓÁÐ¿ØÖÆ¿é
                      if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
                    //Èç¹ûµÃµ½µÄ²»Îª¿Õ£¬¼´ÕæÕýµÃµ½ÁË¡£
                          OSQFreeList         = OSQFreeList->OSQPtr;    /* Yes, Adjust free list pointer to next free*/
                    //µ÷Õû±íÍ·
                          OS_EXIT_CRITICAL();
                    //³õÊ¼»¯ÐÂµÃµ½µÄ¶ÓÁÐ¿ØÖÆ¿é
                          pq->OSQStart        = start;                  /*      Initialize the queue                 */
                          pq->OSQEnd          = &start[size];
                          pq->OSQIn           = start;
                          pq->OSQOut          = start;
                          pq->OSQSize         = size;
                          pq->OSQEntries      = 0;//³õÊ¼»¯ÏûÏ¢ÊýÎªÁã
                          pevent->OSEventType = OS_EVENT_TYPE_Q;//ÉèÖÃÊÂ¼þ¿ØÖÆ¿éÀàÐÍ
                          pevent->OSEventCnt  = 0;//ÐÅºÅÁ¿
                          pevent->OSEventPtr  = pq;//½«´Ë¿éÖ¸ÏòÏûÏ¢¶ÓÁÐ½á¹¹Ö¸Õë
                          OS_EventWaitListInit(pevent);   /*      Initalize the wait list  *///³õÊ¼»¯µÈ´ýÁÐ±í
                      } else {//Èç¹ûÃ»ÓÐµÃµ½¶ÓÁÐ¿ØÖÆ¿é
                          pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
                    //ÒÔ´íÎóÐÎÊ½·µ»Ø¶ÓÁÐ¿ØÖÆ¿é
                          OSEventFreeList    = pevent;//ÍË»ØÊÂ¼þ¿ØÖÆ¿é£¬²»ÓÃÁË¡£
                          OS_EXIT_CRITICAL();
                          pevent = (OS_EVENT *)0;//ÇåÁã£¬¸øÏÂÒ»´ÎÊ¹ÓÃ¡£
                      }
                  }
                  return (pevent);//Èç¹ûÏûÏ¢¶ÓÁÐ½¨Á¢³É¹¦£¬Ôò»á·µ»ØÒ»¸öÖ¸Õë£¬·ñÔò£¬¾Í·µ»Ø¿ÕÖ¸Õë¡£
                  //ÏûÏ¢¶ÓÁÐ³É¹¦ºó·µ»ØµÄÕâ¸öÖ¸ÕëÓÃÓÚÒÔºó¶ÔÏûÏ¢¶ÓÁÐµÄ²Ù×÷Òò´Ë£¬¸ÃÖ¸Õë
                  //¿ÉÒÔ¿´×÷ÊÇÏàÓ¦ÏûÏ¢¶ÓÁÐµÄ¾ä±ú¡£
              }
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        DELETE A MESSAGE QUEUE
              *
              * Description: This function deletes a message queue and readies all tasks pending on the queue.
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired
              *                            queue.
              *
              *              opt           determines delete options as follows:
              *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
              *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
              *                                                    In this case, all the tasks pending will be readied.
              *
              *              err           is a pointer to an error code that can contain one of the following values:
              *                            OS_NO_ERR               The call was successful and the queue was deleted
              *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
              *                            OS_ERR_INVALID_OPT      An invalid option was specified
              *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
              *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
              *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
              *
              * Returns    : pevent        upon error
              *              (OS_EVENT *)0 if the queue was successfully deleted.
              *
              * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 4   

              *                 the queue MUST check the return code of OSQPend().
              *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
              *                 they check 'pevent' to see that it's a NULL pointer.
              *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
              *                 time is directly proportional to the number of tasks waiting on the queue.
              *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
              *                 applications where the queue is used for mutual exclusion because the resource(s)
              *                 will no longer be guarded by the queue.
              *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
              *                 type call) then your application MUST release the memory storage by call the counterpart
              *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
              *                 then, the storage can be reused.
                                                                É¾³ýÒ»¸öÏûÏ¢¶ÓÁÐ
              ÃèÊö£ºÉ¾³ýÒ»¸ö¶ÓÁÐ£¬Ê¹ÔÚ¶ÓÁÐÉÏ¹ÒÆðµÄÈÎÎñÈ«²¿¾ÍÐ÷
              ²ÎÊý£ºpevent £ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿éºÍÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                               opt:¾ö¶¨É¾³ýÑ¡Ïî£¬ÈçÏÂ£º
              *                            opt == OS_DEL_NO_PEND   Ã»ÓÐÈÎÎñ¹ÒÆð²ÅÉ¾³ý
              *                            opt == OS_DEL_ALWAYS    ÓÐÈÎÎñ¹ÒÆðÒ²É¾£¬¹ÒÆðµÄÈÎÎñÈ«²¿¾ÍÐ÷
              *              err          Ö¸Ïò°üº¬ÈçÏÂ´íÎóÐÅÏ¢µÄÖ¸Õë
              *                            OS_NO_ERR              µ÷ÓÃ³É¹¦£¬¶ÓÁÐÉ¾³ý
              *                            OS_ERR_DEL_ISR         Èç¹ûÏë´ÓISRÖÐÉ¾³ý
              *                            OS_ERR_INVALID_OPT      Ö¸¶¨ÁË·Ç·¨Ñ¡Ïî
              *                            OS_ERR_TASK_WAITING     ÓÐÈÎÎñÔÚ¶ÓÁÐÖÐµÈ´ý
              *                            OS_ERR_EVENT_TYPE      Èç¹ûÄãÃ»ÓÐ´«µÝÏûÏ¢¸ø¶ÓÁÐ
              *                            OS_ERR_PEVENT_NULL     Èç¹ûpeventÊÇÒ»¸ö¿ÕÖ¸Õë
              ·µ»Ø£ºpevent£»ÓÐ´í
                               (OS_EVENT *)0Èç¹û¶ÓÁÐ³É¹¦É¾³ý
              ±¸×¢£º1¡¢´Ëº¯ÊýÒªÐ¡ÐÄÊ¹ÓÃ£¬ÈÎÎñÏ£ÍûÏÖ³¡¶ÓÁÐ¼ì²éOSQPend()µÄ·µ»Ø´úÂë£¬Ê²Ã´ÒâË¼£¬²»ÖªµÀ
                              2¡¢OSQAccept()µÄµ÷ÓÃÕß²»ÖªµÀÄ¿±ê¶ÓÁÐÊÇ·ñÉ¾³ýÁË£¬³ý·Ç¼ì²épevent'ÊÇ·ñÎª¿ÕÖ¸Õë
                              3¡¢´Ëµ÷ÓÃ½«Ç±ÔÚ¹ØÖÐ¶ÏÒ»¶ÎÊ±¼ä£¬Ê±¼ä³¤¶ÌÓë¶ÓÁÐÖÐÈÎÎñ¶àÉÙ³ÉÕý±È
                              4¡¢ÒòÎªËùÓÐ¶ÓÁÐÖÐ¹ÒÆðµÄÈÎÎñ¾ÍÐ÷£¬ÔÚ¶àÈÎÎñµÄÊ±ºòÒªÐ¡ÐÄ£¬ÒòÎªÕâÐ©×ÊÔ´
                                     ¶ÓÁÐ²»ÔÙ¿´¹Ü£¨ÒòÎªÉ¾³ýÁË£©¡£
                              5¡¢Èç¹ûÏûÏ¢´æ´¢ÓÃ¶¯Ì¬·ÖÅä£¨±ÈÈçÓÃmalloc()£©£¬ÄÇÃ´Ó¦ÓÃ³ÌÐò±ØÐëÍ¨¹ý
                                      µ÷ÓÃÏàÓ¦µÄ¶¯Ì¬ÅäÖÃÈ¥ÊÍ·ÅÄÚ´æ¿Õ¼ä£¬Èç¹û¶ÓÁÐ´æ´¢ÊÇ¾²Ì¬½¨Á¢£¬Ôò¿ÉÒÔÔÙ´Î
                              ÀûÓÃ
              *********************************************************************************************************
              */
              
              #if OS_Q_DEL_EN > 0
              OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
                  OS_CPU_SR  cpu_sr;
              #endif
                  BOOLEAN    tasks_waiting;
                  OS_Q      *pq;
              
              
                  if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
                      *err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
                      return ((OS_EVENT *)0);
                  }//²»ÄÜÔÚÖÐ¶Ï·þÎñ³ÌÐòÖÐÉ¾³ý
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      *err = OS_ERR_PEVENT_NULL;
                      return (pevent);//pevent²»ºÏÀí
                  }
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
                      *err = OS_ERR_EVENT_TYPE;
                      return (pevent);//·Ç·¨µÄÊÂ¼þ¿éÄ£Ê½
                  }
              #endif
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 5   

                  OS_ENTER_CRITICAL();
                  if (pevent->OSEventGrp != 0x00) {                      /* See if any tasks waiting on queue        */
                  //Èç¹ûÓÐÈÎÎñÔÚ¶ÓÁÐÖÐµÈ´ý
                      tasks_waiting = TRUE;                              /* Yes                                      */
                  } else {
                      tasks_waiting = FALSE;                             /* No                                       */
                  }
                  switch (opt) {
                      case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    //Èç¹ûÖ»ÔÚÎÞÈÎÎñµÈ´ýµÄÇé¿öÏÂÉ¾³ý
                           if (tasks_waiting == FALSE) {//ÎÞÈÎÎñµÈ´ý
                               pq                  = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list        */
                               pq->OSQPtr          = OSQFreeList;
                               OSQFreeList         = pq;//½«Ëü¼ÓÈëÁË¿ÕÏÐÁ´±í
                               pevent->OSEventType = OS_EVENT_TYPE_UNUSED;//±ê¼ÇÎ´ÓÃ
                               pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
                               OSEventFreeList     = pevent; /* Get next free event control block        *///½«ÊÂ¼þ¿ØÖÆ¿
             -é·ÅÈë¿ÕÏÐÁ´±íÖÐ
                               OS_EXIT_CRITICAL();
                               *err = OS_NO_ERR;//ÎÞ´í
                               return ((OS_EVENT *)0);                   /* Queue has been deleted                   */
                           } else {//ÓÐÈÎÎñµÈ´ý
                               OS_EXIT_CRITICAL();
                               *err = OS_ERR_TASK_WAITING;
                               return (pevent);
                           }
              
                      case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    //Ê¼ÖÕÒªÉ¾³ý¶ÓÁÐ
                           while (pevent->OSEventGrp != 0x00) {          /* Ready ALL tasks waiting for queue        */
                      //ÕæÓÐÈÎÎñµÈ´ý
                               OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q);//½«¹ÒÆðµÄÈÎÎñ¾ÍÐ÷
                           }
                           pq                  = (OS_Q *)pevent->OSEventPtr;      /* Return OS_Q to free list        */
                           pq->OSQPtr          = OSQFreeList;
                           OSQFreeList         = pq;//Í¬ÉÏ£¬½«¶ÓÁÐ¿ØÖÆ¿é·ÅÈë¿ÕÏÐÁ´±í
                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;//±ê¼ÇÎªÎ´ÓÃ
                           pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
                           OSEventFreeList     = pevent;                 /* Get next free event control block        */
                     //½«ÊÂ¼þ¿ØÖÆ¿é·ÅÈë¿ÕÏÐÁ´±í
                           OS_EXIT_CRITICAL();
                           if (tasks_waiting == TRUE) {                  /* Reschedule only if task(s) were waiting  */
                               OS_Sched();                               /* Find highest priority task ready to run  */
                       //ÒòÎªÐÂÈÎÎñ¾ÍÐ÷£¬ËùÒÔÒªÖØÐÂµ÷¶È
                           }
                           *err = OS_NO_ERR;
                           return ((OS_EVENT *)0);                       /* Queue has been deleted                   */
              
                      default://ÆäËüÒì³£Çé¿ö
                           OS_EXIT_CRITICAL();
                           *err = OS_ERR_INVALID_OPT;
                           return (pevent);
                  }
              }
              #endif
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                           FLUSH QUEUE
              *
              * Description : This function is used to flush the contents of the message queue.
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 6   

              *
              * Arguments   : none
              *
              * Returns     : OS_NO_ERR           upon success
              *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
              *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                                                                 Çå¿ÕÏûÏ¢¶ÓÁÐ
              ÃèÊö£ºÇå¿ÕÏûÏ¢¶ÓÁÐÖÐÄÚÈÝ
              ²ÎÊý£ºÎÞ
              ·µ»Ø£º
                               OS_NO_ERR          ³É¹¦
              *               OS_ERR_EVENT_TYPE   Ã»ÓÐ´«µÝÖ¸Õë¸ø¶ÓÁÐ
              *               OS_ERR_PEVENT_NULL  Èç¹û'pevent' ÊÇÒ»¸ö¿ÕÖ¸Õë
              
              *********************************************************************************************************
              */
              
              #if OS_Q_FLUSH_EN > 0
              INT8U  OSQFlush (OS_EVENT *pevent)
              {
              #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_Q      *pq;
              
              
              #if OS_ARG_CHK_EN > 0//ÔÊÐí²ÎÊý¼ìÑé
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
                  }//²»ºÏÀíµÄ²ÎÊýpevent
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                      return (OS_ERR_EVENT_TYPE);
                  }//²»ÊÇÊÂ¼þ¿éÀàÐÍ
              #endif
                  OS_ENTER_CRITICAL();
                  pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
                //±£´æ½á¹¹Ö¸Õë
                  pq->OSQIn      = pq->OSQStart;
                  pq->OSQOut     = pq->OSQStart;//½«¶ÓÁÐµÄ²åÈëÖ¸ÕëINºÍÈ¡³öÖ¸ÕëOUT¸´Î»
                  pq->OSQEntries = 0;//³õÊ¼»¯Èë¿ÚÎªÁã
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                     PEND ON A QUEUE FOR A MESSAGE
              *
              * Description: This function waits for a message to be sent to a queue
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
              *
              *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
              *                            wait for a message to arrive at the queue up to the amount of time
              *                            specified by this argument.  If you specify 0, however, your task will wait
              *                            forever at the specified queue or, until a message arrives.
              *
              *              err           is a pointer to where an error message will be deposited.  Possible error
              *                            messages are:
              *
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 7   

              *                            OS_NO_ERR           The call was successful and your task received a
              *                                                message.
              *                            OS_TIMEOUT          A message was not received within the specified timeout
              *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
              *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
              *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
              *                                                would lead to a suspension.
              *
              * Returns    : != (void *)0  is a pointer to the message received
              *              == (void *)0  if no message was received or,
              *                            if 'pevent' is a NULL pointer or,
              *                            if you didn't pass a pointer to a queue.
                                                               µÈ´ýÏûÏ¢¶ÓÁÐÖÐµÄÏûÏ¢
              ÃèÊö£ºµÈ´ýÏûÏ¢ÖÐµÄ¶ÓÁÐ
              ²ÎÊý£ºpevent£ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿é½áºÏÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                              timeout£º³¬Ê±Ê±¼äÑ¡Ïî£¨°´Ê±ÖÓ½ÚÅÄÀ´£©£¬Èç¹û·ÇÁã£¬ÈÎÎñ½«°´ÕÕ´Ë
                                           ²ÎÊýµÄ¶¨Ê±ÔÚ¶ÓÁÐÖÐµÈ´ýÏûÏ¢µ½À´£¬Èç¹ûÉèÖÃÎªÁã£¬ÈÎÎñ½«ÔÚÄ¿±ê
                                           ¶ÓÁÐÖÐÓÀÔ¶µÈ´ý£¬Ö±µ½ÏûÏ¢µ½À´¡£
                              err£ºÖ¸Ïò¿ÉÄÜµÄ´íÎóÏûÏ¢µÄÖ¸Õë£¬¿ÉÄÜÎª£º
              *                            OS_NO_ERR        µ÷ÓÃ³É¹¦£¬ÈÎÎñ½ÓÊÕµ½ÏûÏ¢
              *                            OS_TIMEOUT         ¶¨Ê±Ê±¼äÄÚÏûÏ¢Ã»ÓÐÀ´
              *                            OS_ERR_EVENT_TYPE   ÄãÃ»ÓÐ´«µÝÖ¸Õëµ½¶ÓÁÐ
              *                            OS_ERR_PEVENT_NULL  Èç¹û 'pevent' ÊÇÒ»¸ö¿ÕÖ¸Õë
              *                            OS_ERR_PEND_ISR    Èç¹û´ÓISRÖÐµ÷ÓÃ£¬½á¹û½«³öÏÖÒì³£              
              *********************************************************************************************************
              */
              
              void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  void      *msg;
                  OS_Q      *pq;
              
              
                  if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
                      *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
                      return ((void *)0);//²»ÄÜÔÚISRÖÐ¹ÒÆð
                  }
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                      *err = OS_ERR_PEVENT_NULL;
                      return ((void *)0);//²»ºÏÀíµÄpevent
                  }
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
                      *err = OS_ERR_EVENT_TYPE;
                      return ((void *)0);//²»ÊÇÊÂ¼þ¿éÀàÐÍ
                  }
              #endif
                  OS_ENTER_CRITICAL();
                  pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
                //È¡³ö¶ÓÁÐ¿ØÖÆ¿éÖ¸Õë
                  if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
              //´óÓÚÁã£¬±íÊ¾ÓÐÏûÏ¢¿ÉÒÔÓÃ¡£´ËÊ±£¬OSQPendµÃµ½ÊÂ¼þ¿ØÖÆ¿éµÄ.OSQOutÓòËùÖ¸
              //ÏòµÄÏûÏ¢£¬½«Ö¸ÏòÏûÏ¢µÄÖ¸Õë¸´ÖÆµ½msg±äÁ¿ÖÐ£¬²¢ÈÃ.OSQOutÖ¸ÕëÖ¸Ïò
              //¶ÓÁÐÖÐµÄÏÂ¸öµ¥Ôª
                      msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
                      pq->OSQEntries--;                        /* Update the number of entries in the queue          */
              // ¶ÓÁÐÖÐÓÐÐ§ÏûÏ¢¼õÒ»
                      if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
                          pq->OSQOut = pq->OSQStart;
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 8   

                      }//ÏûÏ¢¶ÓÁÐÊÇÒ»¸öÑ­»·»º³åÇø£¬Èç¹û³¬³öÁË¶ÓÁÐÖÐ×îÄ©Ò»¸öµ¥Ôª£¬·¢Éú
                      //ÕâÖÖÔ½½çÊ±£¬¾ÍÒª½«.OSQOutÖØÐÂµ÷Õûµ½Ö¸Ïò¶ÓÁÐµÄÆðÊ¼µ¥Ôª
                      OS_EXIT_CRITICAL();
                      *err = OS_NO_ERR;
                      return (msg);  /* Return message received      *///·µ»Ø½ÓÊÕµ½µÄÏûÏ¢
                  }
                  OSTCBCur->OSTCBStat |= OS_STAT_Q;            /* Task will have to pend for a message to be posted  */
                //ÉèÖÃÈÎÎñµÄTCB×´Ì¬±êÖ¾£¬ÒÔ±íÃ÷µÈ´ýÏûÏ¢¶ÓÁÐÏûÏ¢µÄÈÎÎñ±»¹ÒÆð
                  OSTCBCur->OSTCBDly   = timeout;              /* Load timeout into TCB                              */
                //×°ÔØ¶¨Ê±Æ÷µ½TCB
                  OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
                //¹ÒÆðÈÎÎñÖ±µ½ÏûÏ¢µ½À´»òÕß³¬Ê±¡£ÔÚÓÃ»§½ø³ÌÖÐ£¬µ÷ÓÃ´Ëº¯ÊýµÄÈÎÎñ
                //²¢²»ÖªµÀÏûÏ¢Ã»ÓÐµ½À´Ö®Ç°×Ô¼º±»¹ÒÆð£¬¶ÓÁÐ½ÓÊÕµ½Ò»ÔòÏûÏ¢»òÕß³¬Ê±
                //Ê±£¬´Ëº¯Êý¾Í»áµ÷ÓÃµ÷¶Èº¯Êý»Ö¸´ÔËÐÐ¡£
                  OS_EXIT_CRITICAL();
                  OS_Sched();                                  /* Find next highest priority task ready to run       */
                //¹ÒÆðºóÒª½øÐÐÈÎÎñµ÷¶È¡£
                  OS_ENTER_CRITICAL();
                  msg = OSTCBCur->OSTCBMsg;//ÈÎÎñµ÷¶Èºó£¬ÈÎÎñ»á¼ì²é´Ëº¯ÊýÊÇ²»ÊÇ½«ÏûÏ¢·Åµ½ÁË
                  //ÈÎÎñµÄTCBÖÐ¡£
                  if (msg != (void *)0) {                      /* Did we get a message?                              */
                  //Èç¹ûÏûÏ¢È·Êµ´æÔÚ¡£
                      OSTCBCur->OSTCBMsg      = (void *)0;     /* Extract message from TCB (Put there by QPost)      */
                  //Çå³ý´ËÏûÏ¢£¿
                      OSTCBCur->OSTCBStat     = OS_STAT_RDY;//¾ÍÐ÷
                      OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0; /* No longer waiting for event                        */
                  //²»ÔÙµÈ´ýÊÂ¼þÁË
                      OS_EXIT_CRITICAL();
                      *err                    = OS_NO_ERR;
                      return (msg);                            /* Return message received                            */
                  }
                  OS_EventTO(pevent);                          /* Timed out                                          */
                //³¬Ê±ÁË¡£
                  OS_EXIT_CRITICAL();
                  *err = OS_TIMEOUT;                           /* Indicate a timeout occured       */
                  return ((void *)0);                          /* No message received      */
              }
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        POST MESSAGE TO A QUEUE
              *
              * Description: This function sends a message to a queue
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
              *
              *              msg           is a pointer to the message to send.  You MUST NOT send a NULL pointer.
              *
              * Returns    : OS_NO_ERR             The call was successful and the message was sent
              *              OS_Q_FULL             If the queue cannot accept any more messages because it is full.
              *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
              *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
              *              OS_ERR_POST_NULL_PTR  If you are attempting to post a NULL pointer
                                                           ÏòÏûÏ¢¶ÓÁÐ·¢ËÍÒ»ÔòÏûÏ¢£¨FIFO£©
              ÃèÊö£º·¢ËÍÒ»ÔòÏûÏ¢µ½¶ÓÁÐ
              ²ÎÊý£ºpevent£ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿éÁªºÏÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                              msg£ºÖ¸ÏòÒª·¢ËÍµÄÏûÏ¢¡£²»ÄÜ·¢ËÍNULL
              ·µ»Ø£ºOS_NO_ERR            ÏûÏ¢³É¹¦·¢ËÍ
              *              OS_Q_FULL             Èç¹û¶ÓÁÐÂúÁË£¬²»ÄÜ½ÓÊÕÏûÏ¢ÁË
              *              OS_ERR_EVENT_TYPE     Èç¹ûÃ»ÓÐ·¢ËÍÏûÏ¢µ½¶ÓÁÐ
              *              OS_ERR_PEVENT_NULL    Èç¹û 'pevent' ÊÇ¿ÕÖ¸Õë
              *              OS_ERR_POST_NULL_PTR  Èç¹ûÄã·¢ËÍ¿ÕÏûÏ¢
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 9   

              *********************************************************************************************************
              */
              
              #if OS_Q_POST_EN > 0
              INT8U  OSQPost (OS_EVENT *pevent, void *msg)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_Q      *pq;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
                  }//²»ºÏÀíµÄpevent
                  if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
                      return (OS_ERR_POST_NULL_PTR);
                  }//±£Ö¤Ã»ÓÐ·¢ËÍ¿ÕÖ¸Õë
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                      return (OS_ERR_EVENT_TYPE);
                  }//·Ç·¨µÄÊÂ¼þ¿éÀàÐÍ
              #endif
                  OS_ENTER_CRITICAL();
                  if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
              //Èç¹ûÓÐÈÎÎñÔÚµÈ
                      OS_EventTaskRdy(pevent, msg, OS_STAT_Q);      /* Ready highest priority task waiting on event  */
              //Ê¹ÔÚÊÂ¼þÖÐµÈ´ýµÄ×î¸ßÓÅÏÈ¼¶ÈÎÎñ¾ÍÐ÷
                      OS_EXIT_CRITICAL();
                      OS_Sched();                                   /* Find highest priority task ready to run       */
                  //ÈÎÎñµ÷¶È
                      return (OS_NO_ERR);
                  }
                  pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
                  if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
                      OS_EXIT_CRITICAL();
                      return (OS_Q_FULL);
                  }
                  *pq->OSQIn++ = msg;                               /* Insert message into queue                     */
                //½«ÏûÏ¢²åÈë
                  pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
                //¸üÐÂ×ÜÏûÏ¢Êý
                  if (pq->OSQIn == pq->OSQEnd) {                    /* Wrap IN ptr if we are at end of queue         */
                      pq->OSQIn = pq->OSQStart;//µ÷½ÚÏûÏ¢¶ÓÁÐÑ­»·»º³åÇø£¬µ±Ô½½çÊ±£¬ÖØÐÂÖ¸ÏòÐÂµÄ¿ªÍ·
                  }
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                   POST MESSAGE TO THE FRONT OF A QUEUE
              *
              * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
              *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
              *              'priority' messages.
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
              *
              *              msg           is a pointer to the message to send.  You MUST NOT send a NULL pointer.
              *
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 10  

              * Returns    : OS_NO_ERR             The call was successful and the message was sent
              *              OS_Q_FULL             If the queue cannot accept any more messages because it is full.
              *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
              *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
              *              OS_ERR_POST_NULL_PTR  If you are attempting to post to a non queue.
                                           ÏòÏûÏ¢¶ÓÁÐ·¢ËÍÒ»ÔòÏûÏ¢£¨LIFO£©
              ÃèÊö£º·¢ËÍÒ»ÔòÏûÏ¢£¬µ«ÓëOSQPost()²»Í¬£¬ÏûÏ¢ÊÇÖ¸ÏòÇ°¶Ë¶ø²»ÊÇ¶ÓÁÐµÄºó¶Ë£¬
                              //ÓÃ´Ëº¯ÊýÔÊÐíÄã·¢ËÍÓÅÏÈ¼¶ÏûÏ¢¡£
              ²ÎÊý£ºpevent£ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿éÁªºÏÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                              smg:Ö¸ÏòÄãÒª·¢ËÍµÄÏûÏ¢£¬²»ÄÜ·¢ËÍ¿ÕÖ¸Õë
              ·µ»Ø£ºOS_NO_ERR             µ÷ÓÃ³É¹¦£¬ÏûÏ¢³É¹¦·¢ËÍ
              *              OS_Q_FULL             Èç¹û¶ÓÁÐÂúÁË£¬²»ÄÜ½ÓÊÕÏûÏ¢ÁË
              *              OS_ERR_EVENT_TYPE     Èç¹ûÃ»ÓÐ·¢ËÍÏûÏ¢µ½¶ÓÁÐ
              *              OS_ERR_PEVENT_NULL   Èç¹û 'pevent' ÊÇ¿ÕÖ¸Õë
              *              OS_ERR_POST_NULL_PTR  Èç¹ûÄãÏë·¢ËÍµ½µÄ²»ÊÇ¶ÓÁÐ
              *********************************************************************************************************
              */
              
              #if OS_Q_POST_FRONT_EN > 0
              INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_Q      *pq;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
                  }}//²»ºÏÀíµÄpevent
                  if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
                      return (OS_ERR_POST_NULL_PTR);
                  }//±£Ö¤Ã»ÓÐ·¢ËÍ¿ÕÖ¸Õë
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                      return (OS_ERR_EVENT_TYPE);
                  }//·Ç·¨µÄÊÂ¼þ¿éÀàÐÍ
              #endif
                  OS_ENTER_CRITICAL();
                  if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
                      OS_EventTaskRdy(pevent, msg, OS_STAT_Q);      /* Ready highest priority task waiting on event  */
                      OS_EXIT_CRITICAL();
                      OS_Sched();                                   /* Find highest priority task ready to run       */
                      return (OS_NO_ERR);//½âÊÍ¼ûÉÏ¸öº¯Êý
                  }
                  pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
                //×°ÔØ¶ÓÁÐ¿ØÖÆ¿éÖ¸Õë
                  if (pq->OSQEntries >= pq->OSQSize) {  /* Make sure queue is not full                   */
                  //±£Ö¤¶ÓÁÐ»¹Ã»ÓÐÂú
                      OS_EXIT_CRITICAL();
                      return (OS_Q_FULL);
                  }//OSQOutÖ¸ÕëÖ¸ÏòµÄÊÇÒÑ¾­²åÈëÁËÏûÏ¢Ö¸ÕëµÄµ¥Ôª£¬ËùÒÔÔÚ²åÈëÐÂµÄÏûÏ¢Ö¸ÕëÇ°£¬
                  //Òª½«OSQOutÖ¸ÕëÔÚÏûÏ¢¶ÓÁÐÖÐÇ°ÒÆÒ»¸öµ¥Ôª£¬
                  if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
                      pq->OSQOut = pq->OSQEnd;//¸üÐÂÑ­»·»º³åÁ´¡£Èç¹ûpq->OSQOutÖ¸ÏòµÄµ±Ç°µ¥ÎÞÊÇ¶Ó
                      //ÁÐÖÐµÄµÚÒ»¸öµ¥Ôª£¬ÔÙÏòÇ°ÒÆµÄ»°¾ÍÒâÎ¶×ÅÖ¸ÏòÁË¶ÓÁÐµÄÄ©Î²
                  }
                  pq->OSQOut--;//OSQEndÖ¸ÏòµÄÊÇÏûÏ¢¶ÓÁÐÖÐ×îºóÒ»¸öµ¥ÔªµÄÏÂÒ»¸öµ¥Ôª£¬ËùÒÔ£¬
                  //ÒªÇó½«Æäµ÷Õûµ½Ö¸Ïò¶ÓÁÐµÄÓÐÐ§·¶Î§ÄÚ¡£ÒòÎªOSQPend£¨£©º¯ÊýÈ¡³öµÄÏûÏ¢
                  //ÊÇÓÉ´Ëº¯Êý¸Õ¸Õ²åÈëµÄ£¬ÕâÑù£¬¾ÍÊµÏÖÁËºó½øÏÈ³ö¡£
                  *pq->OSQOut = msg;                                /* Insert message into queue                     */
                  pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 11  

                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        POST MESSAGE TO A QUEUE
              *
              * Description: This function sends a message to a queue.  This call has been added to reduce code size
              *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
              *              capability to broadcast a message to ALL tasks waiting on the message queue.
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
              *
              *              msg           is a pointer to the message to send.  You MUST NOT send a NULL pointer.
              *
              *              opt           determines the type of POST performed:
              *                            OS_POST_OPT_NONE         POST to a single waiting task
              *                                                     (Identical to OSQPost())
              *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
              *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
              *
              *                            Below is a list of ALL the possible combination of these flags:
              *
              *                                 1) OS_POST_OPT_NONE
              *                                    identical to OSQPost()
              *
              *                                 2) OS_POST_OPT_FRONT
              *                                    identical to OSQPostFront()
              *
              *                                 3) OS_POST_OPT_BROADCAST
              *                                    identical to OSQPost() but will broadcast 'msg' to ALL waiting tasks
              *
              *                                 4) OS_POST_OPT_FRONT + OS_POST_OPT_BROADCAST  is identical to
              *                                    OSQPostFront() except that will broadcast 'msg' to ALL waiting tasks
              *
              * Returns    : OS_NO_ERR             The call was successful and the message was sent
              *              OS_Q_FULL             If the queue cannot accept any more messages because it is full.
              *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
              *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
              *              OS_ERR_POST_NULL_PTR  If you are attempting to post a NULL pointer
              *
              * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
              *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                                            ÏòÏûÏ¢¶ÓÁÐ·¢ËÍÒ»ÔòÏûÏ¢£¨LIFO»òÕßFIFO£©   
              ÃèÊö£ºÒÔ¿ÉÒÔÌæ´úµÄ£¬¸üÁé»îµÄ·½Ê½¸øÏûÏ¢¶ÓÁÐ·¢ÏûÏ¢£¬¿ÉÒÔ´úÌæLIFO»òÕßFIFO
                             ÔÊÐí·¢ËÍÏûÏ¢¸øËùÓÐÏûÏ¢¶ÓÁÐÖÐµÈ´ýÏûÏ¢µÄÈÎÎñ£¨¹ã²¥·½Ê½£©
              ²ÎÊý£ºpevent£ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿éÁªºÏÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                              smg:Ö¸ÏòÄãÒª·¢ËÍµÄÏûÏ¢£¬²»ÄÜ·¢ËÍ¿ÕÖ¸Õë
                              opt:È·¶¨·¢ËÍ·½Ê½£º
              *                            OS_POST_OPT_NONE        ·¢ËÍ¸øµ¥¸öÈÎÎñ£¬Ïàµ±ÓÚOSQPost()
              *                            OS_POST_OPT_BROADCAST   ·¢ËÍ¸ø¶ÓÁÐÖÐËùÓÐµÈ´ýµÄÈÎÎñ
              *                            OS_POST_OPT_FRONT        ÒÔLIFO ·¢ËÍ(Óë OSQPostFront()ÏàËÆ)
                               ÏÂÃæÊÇËùÓÐ±êÖ¾¿ÉÄÜµÄ½áºÏÇé¿ö£º  
              *                                 1) OS_POST_OPT_NONE
              *                                    Ïàµ±ÓÚ OSQPost()
              *
              *                                 2) OS_POST_OPT_FRONT
              *                                    Ïàµ±ÓÚ OSQPostFront()
              *
              *                                 3) OS_POST_OPT_BROADCAST
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 12  

              *                                    Ïàµ±ÓÚ OSQPost() µ«¿ÉÒÔÒÔ¹ã²¥·½Ê½·¢ËÍ to ALL waiting tasks
              *
              *                                 4) OS_POST_OPT_FRONT + OS_POST_OPT_BROADCAST  Ïàµ±ÓÚ
              *                                    OSQPostFront() ¿ÉÒÔÒÔ¹ã²¥·½Ê½·¢ËÍ
              *********************************************************************************************************
              */
              
              #if OS_Q_POST_OPT_EN > 0
              INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_Q      *pq;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
                  }//·Ç·¨pevent 
                  if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
                      return (OS_ERR_POST_NULL_PTR);
                  }//±£Ö¤Ã»ÓÐËÍ¿ÕÖ¸Õë
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                      return (OS_ERR_EVENT_TYPE);
                  }//²»ÊÇÊÂ¼þ¿éÀàÐÍ
              #endif
                  OS_ENTER_CRITICAL();
                  if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
                  //Èç¹ûÓÐÈÎÎñÔÚ¶ÓÁÐÖÐ¹ÒÆð
                      if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
                    //ÏòËùÓÐÈÎÎñ·¢ËÍ£¿
                          while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
                              OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
                          }//ÊÇµÄ¡£Èç¹û½«opt²ÎÊýÖÐµÄOS_POST_OPT_BROADCASTÎ»ÖÃÎª1£¬ÔòËùÓÐÕýÔÚµÈ´ýÏûÏ¢
                          //µÄÈÎÎñ¶¼ÄÜ½ÓÊÕµ½ÕâÔòÏûÏ¢£¬²¢ÇÒ±»OS_EventTaskRdy´ÓµÈ´ýÁÐ±íÖÐÉ¾³ý¡£
                      } else {//²»ÒªÏòËùÓÐµÄµÈ´ýÈÎÎñ·¢ÏûÏ¢
                          OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue             */
                    //ÄÇ¾ÍÖ»·¢ÓÅÏÈ¼¶×î¸ßµÄ¡£
                      }
                      OS_EXIT_CRITICAL();
                      OS_Sched();                                   /* Find highest priority task ready to run       */
                  //ÒªÈÎÎñµ÷¶È
                      return (OS_NO_ERR);
                  }
                  pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
                //Ö¸Ïò¶ÓÁÐ¿ØÖÆ¿é
                  if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
                      OS_EXIT_CRITICAL();//Èç¹ûÂúÁË£¬·µ»Ø´íÎó´úÂë
                      return (OS_Q_FULL);
                  }
                  if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
                  //FIFO»¹ÊÇLIFO£¬Èç¹ûÊÇLIFO
                      if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
                          pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
                      }//Èç¹ûÊÇºó½øÏÈ³ö£¬ÔòÏàµ±ÓÚOSQPostFront ¡£Èç¹ûÎÒÈËÔÚ¶ÓÁÐµÚÒ»¸ö£¬Ôòµ÷Õû
                      pq->OSQOut--;
                      *pq->OSQOut = msg;                            /*      Insert message into queue                */
                  //²åÈëÏûÏ¢
                  } else {                                          /* No,  Post as FIFO                             */
                  //Èç¹ûÊÇFIFO
                      *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 13  

                      if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
                          pq->OSQIn = pq->OSQStart;//Èç¹ûÔÚ×îÄ©Î²£¬Ôòµ÷Õû
                      }
                  }
                  pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
                //¸üÐÂÏûÏ¢ÌõÊý
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                        QUERY A MESSAGE QUEUE
              *
              * Description: This function obtains information about a message queue.
              *
              * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
              *
              *              pdata         is a pointer to a structure that will contain information about the message
              *                            queue.
              *
              * Returns    : OS_NO_ERR           The call was successful and the message was sent
              *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
              *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                                                     »ñÈ¡ÏûÏ¢¶ÓÁÐ×´Ì¬
              ÃèÊö£º»ñÈ¡ÏûÏ¢¶ÓÁÐµÄÐÅÏ¢
              ²ÎÊý£ºpevent£ºÖ¸ÏòÊÂ¼þ¿ØÖÆ¿é½áºÏÄ¿±ê¶ÓÁÐµÄÖ¸Õë
                              pdata£ºÖ¸ÏòÏûÏ¢¶ÓÁÐ°üº¬ÐÅÏ¢µÄ½á¹¹Ö¸Õë
              ·µ»Ø£ºOS_NO_ERR           µ÷ÓÃ³É¹¦£¬ÏûÏ¢³É¹¦·¢ËÍ
              *              OS_ERR_EVENT_TYPE   ÄãÏë»ñÈ¡·Ç¶ÓÁÐµÄÐÅÏ¢
              *              OS_ERR_PEVENT_NULL  Èç¹û 'pevent' ÊÇÒ»¸öNULLÖ¸Õë
              *********************************************************************************************************
              */
              
              #if OS_Q_QUERY_EN > 0
              INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *pdata)
              {
              #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
                  OS_CPU_SR  cpu_sr;
              #endif
                  OS_Q      *pq;
                  INT8U     *psrc;
                  INT8U     *pdest;
              
              
              #if OS_ARG_CHK_EN > 0
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'     */
                      return (OS_ERR_PEVENT_NULL);
                  }//·Ç·¨pevent 
                  if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type   */
                      return (OS_ERR_EVENT_TYPE);
                  }//±£Ö¤Ã»ÓÐËÍ¿ÕÖ¸Õë
              #endif
                  OS_ENTER_CRITICAL();
              //¸´ÖÆµÈ´ýÈÎÎñÁÐ±í
                  pdata->OSEventGrp = pevent->OSEventGrp;           /* Copy message queue wait list  */
                  psrc              = &pevent->OSEventTbl[0];
                  pdest             = &pdata->OSEventTbl[0];
              #if OS_EVENT_TBL_SIZE > 0//´Ó0¿ªÊ¼£¬ÂýÂý¸´ÖÆ°É¡£
                  *pdest++          = *psrc++;
              #endif
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 14  

              
              #if OS_EVENT_TBL_SIZE > 1
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 2
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 3
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 4
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 5
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 6
                  *pdest++          = *psrc++;
              #endif
              
              #if OS_EVENT_TBL_SIZE > 7
                  *pdest            = *psrc;
              #endif
                  pq = (OS_Q *)pevent->OSEventPtr;
                  if (pq->OSQEntries > 0) {//Èç¹ûÓÐÏûÏ¢µÈ´ý£¬ÔòÌáÈ¡³ö£¨²¢Ã»ÓÐÉ¾³ý£©¶ÓÁÐÖÐ×îÔç½øÈë
                  //¶ÓÁÐµÄÏûÏ¢£¬²¢½«Æä¸´ÖÆµ½OSMsgÖÐ£¬OSQQuery²¢Ã»ÓÐ¸Ä¶¯.OSQOutµÄÖ¸Õë¡£
                      pdata->OSMsg = *pq->OSQOut;                        /* Get next message to return if available  */
                  } else {//Èç¹ûÃ»ÓÐÈÎÎñµÈ´ý£¬Ôò·µ»Ø¿ÕÖ¸Õë
                      pdata->OSMsg = (void *)0;
                  }
                  pdata->OSNMsgs = pq->OSQEntries;//¶ÓÁÐÖÐÏûÏ¢Êý
                  pdata->OSQSize = pq->OSQSize;//¶ÓÁÐÈÝÒ×´óÐ¡
                  OS_EXIT_CRITICAL();
                  return (OS_NO_ERR);
              }
              #endif                                                     /* OS_Q_QUERY_EN                            */
              
              /*$PAGE*/
              /*
              *********************************************************************************************************
              *                                      QUEUE MODULE INITIALIZATION
              *
              * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
              *               application MUST NOT call this function.
              *
              * Arguments   :  none
              *
              * Returns     : none
              *
              * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                                                                 ³õÊ¼»¯ÏûÏ¢¶ÓÁÐ
              ÃèÊö£ºÓÉucosµ÷ÓÃ³õÊ¼»¯ÏûÏ¢¶ÓÁÐÄ£ÐÍ£¬Ó¦ÓÃ³ÌÐò²»ÄÜµ÷ÓÃ
              ²ÎÊý£ºÎÞ
              ·µ»Ø£ºÎÞ
              ±¸×¢£ºÓÉucosµ÷ÓÃ³õÊ¼»¯ÏûÏ¢¶ÓÁÐÄ£ÐÍ£¬Ó¦ÓÃ³ÌÐò²»ÄÜµ÷ÓÃ
              *********************************************************************************************************
              */
C51 COMPILER V9.56.0.0   OS_Q                                                              10/21/2017 15:51:50 PAGE 15  

              
              void  OS_QInit (void)
              {
              #if OS_MAX_QS == 1//Èç¹ûÖ»ÓÐÒ»¸ö¶ÓÁÐ
                  OSQFreeList         = &OSQTbl[0];            /* Only ONE queue!     */
                  OSQFreeList->OSQPtr = (OS_Q *)0;//Ç°Ç÷ÎªÁãÖ¸Õë
              #endif
              
              #if OS_MAX_QS >= 2
                  INT16U  i;
                  OS_Q   *pq1;
                  OS_Q   *pq2;
              
              
                  pq1 = &OSQTbl[0];
                  pq2 = &OSQTbl[1];
                  for (i = 0; i < (OS_MAX_QS - 1); i++) {      /* Init. list of free QUEUE control blocks            */
                  //³õÊ¼»¯¿ÕÏÐ¶ÓÁÐ¿ØÖÆ¿é£¬×é³ÉÒ»¸öµ¥ÏòÁ´±í
                      pq1->OSQPtr = pq2;
                      pq1++;
                      pq2++;
                  }
                  pq1->OSQPtr = (OS_Q *)0;//ºóÇ÷¸½Ö¸ÏòNULLÖ¸Õë
                  OSQFreeList = &OSQTbl[0];//¿ÕÁ´±íÖ¸ÕëÖ¸ÏòÊ×µØÖ·¡£
              #endif
              }
              #endif                                                     /* OS_Q_EN                                  */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
